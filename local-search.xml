<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>何时在 Go 中使用泛型</title>
    <link href="/post/when-to-use-generics.html"/>
    <url>/post/when-to-use-generics.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是 Go 官方博客的翻译，原文地址：<a href="https://go.dev/blog/when-generics">when generics</a></p><p>Go 1.18 增加了一个重要的语言特性：对泛型编程的支持。本文不会介绍什么是泛型，如何去使用泛型。而是聚焦于何时在Go代码中使用泛型，又该在何时不使用泛型。</p><p>先说明，本文只是提供一个通用的指引，而非硬性的规定。具体使用的时机取决于你的判断。但是如果你不确定是否该使用，那么你就可以遵循本文的说明。</p><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>首先是从 Go 编程的一般性准则：通过编写代码而非是定义类型来编写 Go 程序。如果在涉及到泛型时，首先想到定义类型参数约束来编写你的程序，那么你可能就走入了一个误区。首先编写函数，在明确了解类型参数的作用后，再添加类型参数约束就是一件很容易的事了。</p><h2 id="类型参数何时有用"><a href="#类型参数何时有用" class="headerlink" title="类型参数何时有用"></a>类型参数何时有用</h2><p>让我们来看看在什么情况下类型参数是有用的</p><h3 id="当使用程序内置的数据结构时"><a href="#当使用程序内置的数据结构时" class="headerlink" title="当使用程序内置的数据结构时"></a>当使用程序内置的数据结构时</h3><p>一种情况就是在使用程序内置的特殊容器进行操作的函数时: map，slice 和 channel。</p><p>如果有一个函数有这种类型的参数，并且函数内部的代码不会对元素的类型有任何的假设，那么使用类型参数就可能是有用的</p><p>举个例子，下面这个函数返回任何类型 map 的所有 key 的 slice：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// MapKeys returns a slice of all the keys in m.</span><br><span class="hljs-comment">// The keys are not returned in any particular order.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapKeys</span>[<span class="hljs-title">Key</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">Val</span> <span class="hljs-title">any</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[Key]Val)</span> []<span class="hljs-title">Key</span></span> &#123;<br>    s := <span class="hljs-built_in">make</span>([]Key, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(m))<br>    <span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>        s = <span class="hljs-built_in">append</span>(s, k)<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码不会对 map 的 key 的类型做出任何的假设，并且它也没有使用 value 的类型。它适用于任何类型的 map。这使得它成为使用泛型的一个好的选择。</p><p>对于这样的函数，除类型参数外的替代方案就是使用反射，但这是一个更为笨拙的方案。在编译时没有静态类型检查，而且在运行时的速度也会变慢。</p><h3 id="通用数据结构"><a href="#通用数据结构" class="headerlink" title="通用数据结构"></a>通用数据结构</h3><p>参数类型有用的另一种情况就是通用数据结构中。一个通用的数据结构就像 slice 或者 map 一样，但是却不是语言内置的，比如链表或者是二叉树。</p><p>目前，使用这种数据结构的程序往往会选择下面中的一种做法，一是用特定的元素类型来编写，或者是使用 interface{} 类型。使用类型参数来替换特定的类型可以使得数据结构更加的通用。使用类型参数来代替 interface{} 类型则可以更有效的存储数据，从而节省内存使用，同时也可以在代码中避免类型断言，在编译期就可以进行完全的类型检查。</p><p>举例来说，一个使用类型参数的二叉树的一部分可能像下面这段代码一样</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Tree is a binary tree.</span><br><span class="hljs-keyword">type</span> Tree[T any] <span class="hljs-keyword">struct</span> &#123;<br>    cmp  <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(T, T)</span> <span class="hljs-title">int</span></span><br>    root *node[T]<br>&#125;<br><br><span class="hljs-comment">// A node in a Tree.</span><br><span class="hljs-keyword">type</span> node[T any] <span class="hljs-keyword">struct</span> &#123;<br>    left, right  *node[T]<br>    val          T<br>&#125;<br><br><span class="hljs-comment">// find returns a pointer to the node containing val,</span><br><span class="hljs-comment">// or, if val is not present, a pointer to where it</span><br><span class="hljs-comment">// would be placed if added.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bt *Tree[T])</span> <span class="hljs-title">find</span><span class="hljs-params">(val T)</span> **<span class="hljs-title">node</span>[<span class="hljs-title">T</span>]</span> &#123;<br>    pl := &amp;bt.root<br>    <span class="hljs-keyword">for</span> *pl != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">switch</span> cmp := bt.cmp(val, (*pl).val); &#123;<br>        <span class="hljs-keyword">case</span> cmp &lt; <span class="hljs-number">0</span>:<br>            pl = &amp;(*pl).left<br>        <span class="hljs-keyword">case</span> cmp &gt; <span class="hljs-number">0</span>:<br>            pl = &amp;(*pl).right<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> pl<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pl<br>&#125;<br><br><span class="hljs-comment">// Insert inserts val into bt if not already there,</span><br><span class="hljs-comment">// and reports whether it was inserted.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(bt *Tree[T])</span> <span class="hljs-title">Insert</span><span class="hljs-params">(val T)</span> <span class="hljs-title">bool</span></span> &#123;<br>    pl := bt.find(val)<br>    <span class="hljs-keyword">if</span> *pl != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    *pl = &amp;node[T]&#123;val: val&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>二叉树的每个节点都包含一个类型为类型参数 T 的值。当二叉树以特定类型参数实例化时，该类型的值将直接存储在节点中。而不是被存储为 interface{} 类型。</p><p>这就是类型参数的合理使用，因为二叉树的结构，包括方法中的代码，在很大程度上独立于元素类型T。</p><p>二叉树并不需要知道如何去比较每种类型 T 的值大小，它通过使用传入的比较函数来进行值的比较。你可以在<code>find</code>方法的第四行 <code>bt.cmp</code> 调用处看到这一点。除此之外，类型参数根本不重要。</p><h3 id="对于类型参数，更适用于函数而非方法"><a href="#对于类型参数，更适用于函数而非方法" class="headerlink" title="对于类型参数，更适用于函数而非方法"></a>对于类型参数，更适用于函数而非方法</h3><p>二叉树的例子表明了另一个准则：当需要实现像比较大小一样的功能时，使用函数要比方法好。</p><p>如果不使用函数，我们也可以定义一个节点的值需要有<code>Compare</code>和<code>Less</code>方法的二叉树。这可以通过对参数类型增加需要有这两种方法的约束来实现，这意味着用于实例化二叉树的类型都需要有这两种方法才行。</p><p>这样做的结果是，任何想将二叉树与<code>int</code>等简单数据类型一起使用的人都必须定义自己的整数类型并编写自己的比较方法。如果我们定义二叉树需要传入比较函数，如上图所示的代码，那么就很容易传递所需的函数。使用函数而非是带有方法的类型约束。</p><h3 id="实现通用方法"><a href="#实现通用方法" class="headerlink" title="实现通用方法"></a>实现通用方法</h3><p>还有一种类型参数十分有用的情况，那就是不同的类型都需要实现一些通用的方法，并且每个类型的实现方式都是相同时。</p><p>举个例子，标准库中的<code>sort.Interface</code>接口。它要求实现它的类型需要实现三个方法：<code>Len</code>,<code>Swap</code> 和 <code>Less</code></p><p>这里有一个为任何 slice 实现 sort.Interface 接口的泛型类型 SortFn</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// SliceFn implements sort.Interface for a slice of T.</span><br><span class="hljs-keyword">type</span> SliceFn[T any] <span class="hljs-keyword">struct</span> &#123;<br>    s    []T<br>    less <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(T, T)</span> <span class="hljs-title">bool</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T])</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s.s)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T])</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    s.s[i], s.s[j] = s.s[j], s.s[i]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s SliceFn[T] Less(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> s.less(s.s[i], s.s[j])<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于任何一个 slice 来说，Len 和  Swap 方法都是相同的。Less 方法需要一个比较函数，也就是 SliceFn 的 Fn 部分。就像之前的二叉树的例子一样，我们在实例化 SliceFn 时传入比较函数</p><p>下面的代码就展示了，如何通过传入比价函数来使用 SortFn 为任何类型的 slice 进行排序</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// SortFn sorts s in place using a comparison function.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SortFn</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>]<span class="hljs-params">(s []T, less <span class="hljs-keyword">func</span>(T, T)</span> <span class="hljs-title">bool</span>)</span> &#123;<br>    sort.Sort(SliceFn[T]&#123;s, cmp&#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这类似于标准库函数 sort.Slice，但比较函数是使用值而不是切片索引编写的。</p><p>对这类代码使用类型参数是合适的，因为所有切片类型的方法看起来都完全相同。</p><p>（需要注意的是，Go 1.19-而不是1.18-很可能包括一个使用比较函数对切片进行排序的泛型函数，而该泛型函数很可能不使用sort.Interface。见<a href="https://go.dev/issue/47619">提案#47619</a>。）</p><h2 id="类型参数何时没用"><a href="#类型参数何时没用" class="headerlink" title="类型参数何时没用"></a>类型参数何时没用</h2><p>现在让我们来谈谈问题的另一面：类型参数何时是没用的</p><h3 id="不要用类型参数替换接口"><a href="#不要用类型参数替换接口" class="headerlink" title="不要用类型参数替换接口"></a>不要用类型参数替换接口</h3><p>我们都知道，Go 有着接口类型。 接口可以看作是一种泛型编程。</p><p>例如，广泛使用的 <code>io.Reader</code> 接口提供了一个通用机制，用于从任何包含信息（例如文件）或生成信息（例如随机数生成器）的值中读取数据。如果只是需要调用某个类型的值的方法时，使用接口，而不是类型参数。<code>io.Reader</code>易读，高效和有效的。没有必要去使用类型参数调用一个值的 Read 方法来读取数据。</p><p>举例来说，将这里仅使用接口类型的第一个函数签名更改为使用类型参数的第二版本可能会很诱人</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadSome</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadSome</span>[<span class="hljs-title">T</span> <span class="hljs-title">io</span>.<span class="hljs-title">Reader</span>]<span class="hljs-params">(r T)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span><br></code></pre></div></td></tr></table></figure><p>不要做这种改变。省略类型参数使函数更容易写入，更容易读取，并且执行时间可能相同。</p><p>值得强调的是最后一点，虽然可以以几种不同的方式实现泛型，并且实现会随着时间的推移而变化和改进，但Go 1.18中使用的实现在许多情况下将处理类型为类型参数的值，就像对待类型为接口类型的值一样。这意味着使用类型参数通常不会比使用接口类型更快。因此，不要仅仅为了速度而从接口类型更改为类型参数，因为它可能不会运行得更快。</p><h3 id="如果方法的实现不同，不要使用泛型"><a href="#如果方法的实现不同，不要使用泛型" class="headerlink" title="如果方法的实现不同，不要使用泛型"></a>如果方法的实现不同，不要使用泛型</h3><p>在决定是使用类型参数还是接口类型时，请考虑方法的实现。在之前我们说过，当实现的方法对所有的类型都是相同的时候，使用类型参数。相反地，如果每种类型的方法实现都是不同的，那么就使用接口类型，编写不同的方法实现，而不是使用类型参数。</p><p>例如，<code>File</code> 类型的 <code>Read</code>方法实现与随机数生成器 <code>Read</code>方法的实现不同。这意味着我们应该编写里两个不同的 Read 方法，使用一个接口类型就像是 <code>io.Reader</code>。</p><h3 id="酌情使用反射"><a href="#酌情使用反射" class="headerlink" title="酌情使用反射"></a>酌情使用反射</h3><p>Go 拥有运行时反射。反射可以做到泛型编程，因为它允许你编写适用于任何类型的代码。</p><p>如果某些操作甚至必须支持没有方法的类型（因此接口类型没有帮助），并且如果每种类型的操作都不同（因此类型参数不合适），那么在这种情况下请使用反射。</p><p>这种情况的一个例子就是 <code>encoding/json</code> 包。我们不希望编写的每种类型都有一个MarshalJSON方法，因此我们不能使用接口类型。但对接口类型序列化与对结构类型进行序列化的方式又完全不一样，因此我们也不能使用类型参数。相反，该包使用了反射。实现的代码并不简单，但很有效。更多细节见<a href="https://go.dev/src/encoding/json/encode.go">源码</a></p><h2 id="一个简答的指南"><a href="#一个简答的指南" class="headerlink" title="一个简答的指南"></a>一个简答的指南</h2><p>最后，关于何时使用泛型的讨论可以简化为一个简单的指南。</p><p>如果你发现自己多次写完全相同的代码，其中唯一的区别是代码使用了不同的类型，考虑是否可以使用类型参数。</p><p>换句话说，你应该避免使用类型参数，直到你注意到你要多次编写完全相同的代码。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建一个 mongo replica set</title>
    <link href="/post/build-local-mongo-rs.html"/>
    <url>/post/build-local-mongo-rs.html</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍如何在本地搭建一个 3 节点的mongo replica set。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>在官方的 <a href="https://www.mongodb.com/try">下载中心</a> 选择对应平台的安装包，解压并安装完成</li><li>将 mongod 以及配套的工具路径加入 $PATH</li><li>命令行终端</li></ul><p>打开命令行，输入如下的代码：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mongod --dbpath &lt;data_dir&gt; --port 27017<br></code></pre></div></td></tr></table></figure><p>上面的代码将会启动一个 mongod 的实例，监听 27017 端口。所有的数据都会存放在指定的 <em>data_dir</em> 下</p><h3 id="搭建-Replica-Set"><a href="#搭建-Replica-Set" class="headerlink" title="搭建 Replica Set"></a>搭建 Replica Set</h3><h4 id="1-创建存放数据的目录"><a href="#1-创建存放数据的目录" class="headerlink" title="1. 创建存放数据的目录"></a>1. 创建存放数据的目录</h4><p>MongoDB 需要一个数据目录来存放所有的数据文件, </p><p>打开命令行，并输入下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> ~</span><br><span class="hljs-meta">$</span><span class="bash"> mkdir -p data/db&#123;1,2,3&#125;</span><br></code></pre></div></td></tr></table></figure><p>上面的代码将会在用户的家目录下创建 data 目录，并在 data 下创建 db1, db2, db3 三个文件夹，分别用于存储三个节点的数据文件</p><h4 id="2-准备配置文件"><a href="#2-准备配置文件" class="headerlink" title="2. 准备配置文件"></a>2. 准备配置文件</h4><p>正常情况下，三个节点的实例会运行在三个不同的服务器上，现在为了测试，需要在本地启动三个进程，因此需要三个不同的配置文件，并且满足下面的需求</p><ul><li>服务需要监听三个不同的端口，分别是 27017， 27018， 27019</li><li>三个不同的数据存放目录，在第一步中以及创建好了</li><li>三个不同位置的日志文件，分别是 ~/data/db1/mongod.log, ~/data/db2/mongod.log, ~/data/db3/mongod.log</li></ul><p>创建 db1 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db1/mongod.conf</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> systemLog:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   destination: file</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   path:  ~/data/db1/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   logAppend: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> storage:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   dbPath: ~/data/db1  # 数据目录</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> net:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   bindIp: 0.0.0.0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   port: 27017   # 端口</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> replication:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   replSetName: rs0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> processManagement:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   fork: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> EOF</span></span><br></code></pre></div></td></tr></table></figure><p>创建 db2 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db2/mongod.conf</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> systemLog:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   destination: file</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   path:  ~/data/db2/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   logAppend: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> storage:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   dbPath: ~/data/db2  # 数据目录</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> net:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   bindIp: 0.0.0.0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   port: 27018   # 端口</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> replication:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   replSetName: rs0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> processManagement:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   fork: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> EOF</span></span><br></code></pre></div></td></tr></table></figure><p>创建 db3 的配置文件，在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat &lt;&lt; <span class="hljs-string">EOF &gt; ~/data/db3/mongod.conf</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> systemLog:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   destination: file</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   path:  ~/data/db3/mongod.log   # 日志文件路径</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   logAppend: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> storage:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   dbPath: ~/data/db3  # 数据目录</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> net:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   bindIp: 0.0.0.0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   port: 27019   # 端口</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> replication:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   replSetName: rs0</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> processManagement:</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string">   fork: true</span></span><br><span class="hljs-meta">&gt;</span><span class="bash"><span class="hljs-string"> EOF</span></span><br></code></pre></div></td></tr></table></figure><h4 id="3-启动进程"><a href="#3-启动进程" class="headerlink" title="3. 启动进程"></a>3. 启动进程</h4><p>在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mongod -f ~/data/db1/mongod.conf</span><br><span class="hljs-meta">$</span><span class="bash"> mongod -f ~/data/db2/mongod.conf</span><br><span class="hljs-meta">$</span><span class="bash"> mongod -f ~/data/db3/mongod.conf</span><br></code></pre></div></td></tr></table></figure><p>粘贴下面的代码，查看服务是否正常启动</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> ps -ef | grep mongo</span><br></code></pre></div></td></tr></table></figure><h4 id="4-配置"><a href="#4-配置" class="headerlink" title="4. 配置"></a>4. 配置</h4><p>在命令行下粘贴下面的代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mongo</span><br><span class="hljs-meta">&gt;</span><span class="bash"> rs.initiate(&#123;</span><br>    _id: &quot;rs0&quot;,<br>    members: [&#123;<br>        _id: 0,<br>        host: &quot;localhost:27017&quot;<br>    &#125;,&#123;<br>        _id: 1,<br>        host: &quot;localhost:27018&quot;<br>    &#125;,&#123;<br>        _id: 2,<br>        host: &quot;localhost:27019&quot;<br>    &#125;]<br>&#125;)<br><span class="hljs-meta">&gt;</span><span class="bash"> rs.status()</span><br></code></pre></div></td></tr></table></figure><p>上面的代码会连接 mongod 1，并打开 mongo shell，然后在 mongo shell 中初始化了 rs，完成后使用 <code>rs.status()</code>查看 rs 的信息。</p><p>至此，一个单机版的 replica set 就搭建完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/post/binary-search.html"/>
    <url>/post/binary-search.html</url>
    
    <content type="html"><![CDATA[<p>二分查找（又成折半查找），是一种在<strong>有序数组</strong>中查找特定元素的算法。</p><p>算法的时间复杂度是：O(logn)。</p><p>注意：该算法的前提是输入的数组必须是有序的，并且数组中的元素是可以比较的。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这里以 Go 标准库的实现来演示，位置为 sort 包</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// func GuessingGame() &#123;</span><br><span class="hljs-comment">//var s string</span><br><span class="hljs-comment">//fmt.Printf(&quot;Pick an integer from 0 to 100.\n&quot;)</span><br><span class="hljs-comment">//answer := sort.Search(100, func(i int) bool &#123;</span><br><span class="hljs-comment">//fmt.Printf(&quot;Is your number &lt;= %d? &quot;, i)</span><br><span class="hljs-comment">//fmt.Scanf(&quot;%s&quot;, &amp;s)</span><br><span class="hljs-comment">//return s != &quot;&quot; &amp;&amp; s[0] == &#x27;y&#x27;</span><br><span class="hljs-comment">//&#125;)</span><br><span class="hljs-comment">//fmt.Printf(&quot;Your number is %d.\n&quot;, answer)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>) <span class="hljs-title">int</span></span> &#123;<br>i, j := <span class="hljs-number">0</span>, n<br><span class="hljs-keyword">for</span> i &lt; j &#123;<br>h := <span class="hljs-keyword">int</span>(<span class="hljs-keyword">uint</span>(i+j) &gt;&gt; <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> !f(h) &#123;<br>i = h + <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>j = h<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> i<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述代码中：</p><ul><li><p>数组的长度 n, 以及传入的回调函数 f， f 返回索引处的值是否与目标值相同。之所以传入一个回调函数 F 而不是特定数组，是因为 Go 目前的版本（1.17) 还不支持泛型，所以为了支持不同类型的数组查找，需要使用闭包函数来获取特定位置值，正如注释代码所示。并且， 定义 f(-1) == false and f(n) == true.</p></li><li><p>创建两个变量，指向当前查找范围的头尾，j = n 是为了处理目标元素刚好在切片尾部的情况</p></li><li><p>当查找范围的左边界面小于右边界时，进行下面的操作</p></li><li><p>选择当前范围中部的值，使用 <code>int(uint(i+j) &gt;&gt; 1)</code> 而非 <code>(i + j) / 2 </code>获取中间索引的原因是为了防止整数越界</p></li><li><p>将中间位置的值与目标值比较，如果小于目标值，说明目标值在右半部区域，移动左边界。反之则说明在左部区域中，需要移动右边界。循环处理，只到中间位置的值等于目标值，或者遍历完所有元素后退出循环</p></li><li><p>最后返回结果 i，由于 i == j, f(i-1) == false, and f(j) (= f(i)) == true  所以答案是 i 。如果目标元素不存在，i = n, 越界，所以需要判断最后的结果是否为合法索引值。</p></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>在目标序列中查找特定值（需要预先排序）</li><li>将目标值插入有序列时，获取对应的索引</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 泛型预览</title>
    <link href="/post/go-generics.html"/>
    <url>/post/go-generics.html</url>
    
    <content type="html"><![CDATA[<p>即将发布的 Go 1.18 将会带来一个巨大的更新：泛型。</p><blockquote><p>官方教程：<a href="https://go.dev/doc/tutorial/generics">https://go.dev/doc/tutorial/generics</a></p></blockquote><p>这篇文章是对官方指引的翻译。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在正式尝试泛型之前，需要做如下的工作</p><ol><li>安装 go1.18beta1 或更新的版本。安装方式请看 beta版本的安装与使用</li><li>一个可以编辑代码的编辑器，任何你喜欢的编辑器都可以</li><li>命令行终端，在 Linux 和 mac 上可以使用自带的 terminal，在 Windows 上可以使用 powershell 或者 cmd</li></ol><h4 id="安装并使用测试版-Go-工具链"><a href="#安装并使用测试版-Go-工具链" class="headerlink" title="安装并使用测试版 Go 工具链"></a>安装并使用测试版 Go 工具链</h4><p>由于 Go1.18 还未正式发布，因此我们需要安装测试版工具链来尝鲜，按照如下的步骤来安装：</p><ol><li><p>运行下面的命令来安装测试版</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go install golang.org/dl/go1.18beta2@latest</span><br></code></pre></div></td></tr></table></figure></li><li><p>运行下面的命令来下载更新</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go1.18beta2 download</span><br></code></pre></div></td></tr></table></figure></li><li><p>使用测试版本程序取代原有的 go 命令（如果安装了正式版的 go）</p><p>可以直接使用测试版的名字，或者将 <code>go</code>设置为测试版程序的别名</p><ul><li><p>直接使用测试版，你可以运行下面的命令来调用测试版程序来取代 <code>go</code> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go1.18beta2 version</span><br></code></pre></div></td></tr></table></figure></li><li><p>将 <code>go</code>设置为别名，可以让测试版的使用更加简单</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">alias</span> go=go1.18beta2</span><br><span class="hljs-meta">$</span><span class="bash"> go version</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ol><p>之后的命令将会默认你已经设置了别名</p><h3 id="创建一个代码文件夹"><a href="#创建一个代码文件夹" class="headerlink" title="创建一个代码文件夹"></a>创建一个代码文件夹</h3><p>首先需要一个文件夹来存放测试代码</p><ol><li><p>打开命令行，进入家目录</p><p>在 Linux 或者 Mac 上</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span></span><br></code></pre></div></td></tr></table></figure><p>在 Windows 上</p><figure class="highlight cmd"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmd"><span class="hljs-function">C:\&gt; <span class="hljs-title">cd</span> %<span class="hljs-title">HOMEPATH</span>%</span><br></code></pre></div></td></tr></table></figure><p>教程的其余部分将显示$作为提示。您使用的命令也可以在Windows上使用。</p></li><li><p>在命令行行中创建一个目录</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir generics</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> generics</span><br></code></pre></div></td></tr></table></figure></li><li><p>创建一个新的 Go module 来存放代码</p><p>运行<code>go mod init</code>命令，并给定模块的路径</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go mod init example/generics</span><br>go: creating new go.mod: module example/generics<br></code></pre></div></td></tr></table></figure><p><strong>注意:</strong> 对于生产代码, 你需要指定一个与你的需求更加契合的模块路径。更多信息可以参考 <a href="https://go.dev/doc/modules/managing-dependencies">Managing dependencies</a>.</p></li></ol><p>接下来，你将会写一些简单的代码来接触泛型</p><h3 id="新增一个非泛型函数"><a href="#新增一个非泛型函数" class="headerlink" title="新增一个非泛型函数"></a>新增一个非泛型函数</h3><p>在这一步，你将会增加两个函数，每个函数都会将 map 中的值相加，然后返回最终的和。</p><p>之所以会定义两个函数，是因为有两种不同类型的 map 需要被处理：一种的值类型为 int64，另一种的值类型则是 float64.</p><h4 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>用你的编辑器在目录下创建一个 <code>main.go</code>文件，你将会在这个文件中创建代码</p></li><li><p>在 main.go 文件的最顶部，粘贴下面的包声明语句</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br></code></pre></div></td></tr></table></figure><p>一个独立的可执行程序（而不是库）入口总是在 main 包中。</p></li><li><p>在包声明语句下方粘贴下面的函数代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// SumInts adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">int64</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">int64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumFloats adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">float64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上述的代码中，你做了如下的事：</p><ul><li>定义了两个函数，每个函数都会将 map 中的值相加，然后返回最终的和。<ul><li>SumInts 处理 string-int64 类型的 map</li><li>SumFloats 处理 string-float64 类型的 map</li></ul></li></ul></li><li><p>在 main.go 中，包声明语句的下方粘贴 main 方法的代码。在 main 方法中，会初始化两个 map，并且将它们作为参数传入在上一步中定义的方法内。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Initialize a map for the integer values</span><br>    ints := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>:  <span class="hljs-number">34</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">12</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize a map for the float values</span><br>    floats := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>:  <span class="hljs-number">35.98</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">26.99</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,<br>        SumInts(ints),<br>        SumFloats(floats))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在上面的代码中，做了如下的事情：</p><ul><li>初始化了值类型为 float64 的 map 和值类型为 int64 的 map，每个 map 都有两个元素</li><li>调用上一步定义的函数来获取每个 map 中的值的和</li><li>将结果打印出来</li></ul></li><li><p>在 main.go 中，就在包定义语句的下方，导入刚刚书写的代码中所需要的包。</p><p>第一行代码应该如下所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">pacakge main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p>保存 main.go</p></li></ol><h4 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go run .</span><br>Non-Generic Sums: 46 and 62.97<br></code></pre></div></td></tr></table></figure><p>通过使用泛型，你可以使用一个函数来完成需求。在接下来的步骤中，将会添加一个函数来处理值类型为 int64 或 float64 的 map。</p><h3 id="新增一个泛型函数来处理多种类型"><a href="#新增一个泛型函数来处理多种类型" class="headerlink" title="新增一个泛型函数来处理多种类型"></a>新增一个泛型函数来处理多种类型</h3><p>在这一节，你将会添加一个泛型函数，它接受值类型为 float64 或 int64 的 map 作为参数，使用单个函数就可以高效的替换原有的两个函数。</p><p>为了支持任一类型的值，这个函数需要一种方法来声明它支持的类型。另一方面，函数的调用者需要一种方法来指定传入的 map 是float64 还是 int64 的。</p><p>为了支持这一点，你将编写一个函数，除了普通的函数参数外，还会声明<em>类型参数</em>。这些类型参数使函数具有通用性（泛型），使其能够处理不同类型的参数。你将使用类型参数和普通函数参数调用函数。</p><p>每个参数类型都有着一个<em>类型约束</em>（<em>type constraint</em> ），作为参数类型的元类型（meta-type）。每个类型约束都指定了，在调用函数时所允许传入的参数类型。</p><p>虽然类型约束通常代表了一组类型，但在编译时，类型参数代表了单个类型——函数调用者提供的参数类型的类型。如果类型参数的类型不符合类型约束，那么代码将无法编译。</p><p>请记住，类型参数必须支持泛型代码在该类型上执行的所有操作。例如，如果函数的代码试图对约束包含 int 类型参数执行 string 操作（如 strings.Index ），那么代码将无法通过编译。</p><p>在即将编写的代码中，你将会使用允许 int 以及 float 的类型约束。</p><h4 id="编写代码-1"><a href="#编写代码-1" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>在上一节新增的代码下方，粘贴泛型函数的代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// SumIntsOrFloats sums the values of map m. It supports both int64 and float64</span><br><span class="hljs-comment">// as types for map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumIntsOrFloats</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">int64</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> <span class="hljs-title">V</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这段代码中：</p><ul><li>定义了 SumIntsOrFloats 函数，该函数包含了两个类型参数（在方括号中）K 和 V，以及一个类型为 map[K]V 的参数 m。函数的返回值类型为 V</li><li>指定 K 的类型约束为 comparable。 comparable 是 go 预设的一个类型约束。它允许任何满足约束的类型的值都可以用作比较运算符 == 和  !=。这是因为在 Go 中 map 的 key 的类型必须是可比较的。因此将 K 设为 comparable 就是非常必要的了，你可以使用 K 来作为 map 的key。同时保证了调用者只使用被允许的类型的 key。</li><li>指定 V 的类型约束为 int64 和 float64 两种类型的联合类型。使用操作符｜指定两种类型的联合类型，表示该约束允许其中的任意一种类型。编译器允许这两种类型作为参数的类型传入函数。</li><li>指定了 m 的类型为 map[K]V，K，V 的类型已经被类型参数所指定了。需要注意的是， map[K]V 是一个合法的 map 类型，因为K 已经被声明为 comparable 了。如果没有将 K 声明为 comparable，编译器将拒绝 map[K]V 的使用</li></ul></li><li><p>在 main.go 中，粘贴下面的代码到原有代码的下方</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums: %v and %v\n&quot;</span>,<br>    SumIntsOrFloats[<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int64</span>](ints),<br>    SumIntsOrFloats[<span class="hljs-keyword">string</span>, <span class="hljs-keyword">float64</span>](floats))<br></code></pre></div></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>调用了刚才定义的泛型函数，传入了创建的 map</p></li><li><p>指定了类型参数 –  包含在方括号中的类型的名称 - 表明在调用时需要被替换的类型参数的类型</p><p>正如下一节中看到的，通常可以在函数调用中省略类型参数。Go编译器通常可以从你的代码中推断它们。</p></li><li><p>打印函数的返回值</p></li></ul></li></ol><h4 id="运行代码-1"><a href="#运行代码-1" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br></code></pre></div></td></tr></table></figure><p>要运行代码，在每次调用中，编译器都会将类型参数替换为该调用中指定的具体类型。</p><p>在调用泛型函数时，通过指定类型参数，来告诉编译器使用哪些类型来代替函数的类型参数。</p><h3 id="在调用泛型函数时移除类型参数"><a href="#在调用泛型函数时移除类型参数" class="headerlink" title="在调用泛型函数时移除类型参数"></a>在调用泛型函数时移除类型参数</h3><p>在本节中，你将添加泛型函数调用的修改版本，进行小幅更改以简化调用代码。将会删除类型参数，在这种情况下，这些参数不需要。</p><p>当Go编译器可以推断要使用的类型时，可以在调用代码时省略类型参数。编译器从函数参数的类型中推断类型参数。</p><p>请注意，这并不总是可行的。例如，如果在需要调用没有参数的泛型函数时，需要在函数调用中包含类型参数。</p><h4 id="编写代码-2"><a href="#编写代码-2" class="headerlink" title="编写代码"></a>编写代码</h4><ul><li><p>在 main.go 中，粘贴下面的代码到原有代码的下方</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,<br>    SumIntsOrFloats(ints),<br>    SumIntsOrFloats(floats))<br></code></pre></div></td></tr></table></figure><p> 在这段代码中：</p><ul><li>调用了泛型函数，并省略了类型参数</li></ul></li></ul><h4 id="运行代码-2"><a href="#运行代码-2" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br>Generic Sums, type parameters inferred: 46 and 62.97<br></code></pre></div></td></tr></table></figure><p>接下来，你会定义一个可以重用的类型约束，该约束的类型为整数和浮点的联和类型，通过在代码中使用该约束来进一步简化代码。</p><h3 id="定义类型约束"><a href="#定义类型约束" class="headerlink" title="定义类型约束"></a>定义类型约束</h3><p>在最后这一节，你将会把之前定义的约束放进它自己的 interface 中，这样的话就可以在不同的地方重用它了。以这种方式声明约束有助于简化代码，例如当约束更复杂时。</p><p>你可以将类型约束定义为一个 interface。约束允许任何类型去实现接口。例如，声明了一个具有三种方法的类型约束接口，然后将其与泛型函数中的类型参数一起使用，则用于调用函数的类型参数必须具有所有的这些方法。</p><p>约束接口也可以引用特定类型，您将在本节中看到。</p><h4 id="编写代码-3"><a href="#编写代码-3" class="headerlink" title="编写代码"></a>编写代码</h4><ol><li><p>就在 main 函数的上方，在导入语句之后，粘贴以下代码以声明类型约束。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Number <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-keyword">int64</span> | <span class="hljs-keyword">float64</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>声明要用作类型约束的Number接口类型。</p></li><li><p>在接口内部声明了 int64 | float64 的联合类型。</p><p>本质上，是将联合类型从函数声明移动到新的类型约束中。这样，当你想将类型参数限制为int64或float64时，就可以使用此Number 类型约束，而不是写出 int64 ｜float64。</p></li></ul></li><li><p>在原有函数的下方，粘贴下面的代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// SumNumbers sums the values of map m. It supports both integers</span><br><span class="hljs-comment">// and floats as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumNumbers</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">Number</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> <span class="hljs-title">V</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在这段代码中：</p><ul><li>以与之前声明的泛型函数相同的逻辑声明泛型函数，但使用新的接口类型而不是联合作为类型约束。和之前前一样，使用参数和返回类型的类型参数</li></ul></li><li><p>在 main.go 中，原有代码的下方，粘贴下列代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,<br>    SumNumbers(ints),<br>    SumNumbers(floats))<br></code></pre></div></td></tr></table></figure><p>在这段代码中：</p><ul><li><p>对每个 map 调用 SumNumbers，并打印每个结果。</p><p>与上一节一样，在对泛型函数的调用中省略了类型参数（方括号内的类型名称）。Go编译器可以从其他参数推断类型参数。</p></li></ul></li></ol><h4 id="运行代码-3"><a href="#运行代码-3" class="headerlink" title="运行代码"></a>运行代码</h4><p>在包含 main.go 的目录中的命令行中，运行代码:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go run .</span><br>Non-Generic Sums: 46 and 62.97<br>Generic Sums: 46 and 62.97<br>Generic Sums, type parameters inferred: 46 and 62.97<br>Generic Sums with Constraint: 46 and 62.97<br></code></pre></div></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Number <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-keyword">int64</span> | <span class="hljs-keyword">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Initialize a map for the integer values</span><br>    ints := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-number">34</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">12</span>,<br>    &#125;<br><br>    <span class="hljs-comment">// Initialize a map for the float values</span><br>    floats := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>&#123;<br>        <span class="hljs-string">&quot;first&quot;</span>: <span class="hljs-number">35.98</span>,<br>        <span class="hljs-string">&quot;second&quot;</span>: <span class="hljs-number">26.99</span>,<br>    &#125;<br><br>    fmt.Printf(<span class="hljs-string">&quot;Non-Generic Sums: %v and %v\n&quot;</span>,<br>        SumInts(ints),<br>        SumFloats(floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums: %v and %v\n&quot;</span>,<br>        SumIntsOrFloats[<span class="hljs-keyword">string</span>, <span class="hljs-keyword">int64</span>](ints),<br>        SumIntsOrFloats[<span class="hljs-keyword">string</span>, <span class="hljs-keyword">float64</span>](floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums, type parameters inferred: %v and %v\n&quot;</span>,<br>        SumIntsOrFloats(ints),<br>        SumIntsOrFloats(floats))<br><br>    fmt.Printf(<span class="hljs-string">&quot;Generic Sums with Constraint: %v and %v\n&quot;</span>,<br>        SumNumbers(ints),<br>        SumNumbers(floats))<br>&#125;<br><br><span class="hljs-comment">// SumInts adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumInts</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int64</span>)</span> <span class="hljs-title">int64</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">int64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumFloats adds together the values of m.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumFloats</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s <span class="hljs-keyword">float64</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumIntsOrFloats sums the values of map m. It supports both floats and integers</span><br><span class="hljs-comment">// as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumIntsOrFloats</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">int64</span> | <span class="hljs-title">float64</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> <span class="hljs-title">V</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// SumNumbers sums the values of map m. Its supports both integers</span><br><span class="hljs-comment">// and floats as map values.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumNumbers</span>[<span class="hljs-title">K</span> <span class="hljs-title">comparable</span>, <span class="hljs-title">V</span> <span class="hljs-title">Number</span>]<span class="hljs-params">(m <span class="hljs-keyword">map</span>[K]V)</span> <span class="hljs-title">V</span></span> &#123;<br>    <span class="hljs-keyword">var</span> s V<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> m &#123;<br>        s += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Cloudflare worker搭建壁纸服务</title>
    <link href="/post/cloudflare-wallpaper-server.html"/>
    <url>/post/cloudflare-wallpaper-server.html</url>
    
    <content type="html"><![CDATA[<p>写这篇文章的原因是记录一下自己为博客首页设置主题图的过程。</p><p>当前博客的主题使用的是 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>, 可以在主页设置主题图。一开始使用的是默认的图片，但是觉得不够个性化，于是就想设置一个专属的图片。</p><p>在思考选用何种图片的过程中，萌发了一个新的想法💡，就是让自己的主题图片定期去变化。但是并不想每次去手动修改图片的链接。于是便想搭建一个图片的服务，可以定期更新图片。</p><p>在思考如何搭建服务时，突然想到 <a href="https://www.bing.com/">bing</a> 的每日背景图片都会改变，刚好符合我的要求。借助 bing 的接口，我只需要搭建一个静态的链接服务，将图片请求重定向至 bing 的图片链接即可。</p><h3 id="获取-bing-的图片接口"><a href="#获取-bing-的图片接口" class="headerlink" title="获取 bing 的图片接口"></a>获取 bing 的图片接口</h3><p>根据 <a href="https://stackoverflow.com/a/18096210/16435968">stackoverflow 上的回答</a> 获取到了 bing 的每日接口请求，获取不同响应接口体的接口如下:</p><blockquote><p><strong>XML:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=xml&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p><p><strong>JSON:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p><p><strong>RSS:</strong> <a href="http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US">http://www.bing.com/HPImageArchive.aspx?format=rss&amp;idx=0&amp;n=1&amp;mkt=en-US</a></p></blockquote><p>使用 <a href="https://httpie.io/">httpie</a> 测试响应的接口</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> http <span class="hljs-string">&quot;http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US&quot;</span></span><br></code></pre></div></td></tr></table></figure><p>响应的 Body 如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;images&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;bot&quot;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">&quot;copyright&quot;</span>: <span class="hljs-string">&quot;Flamenco dancers outside Palma de Majorca, Spain (© Torleif Svensson/Getty Images)&quot;</span>,<br>            <span class="hljs-attr">&quot;copyrightlink&quot;</span>: <span class="hljs-string">&quot;https://www.bing.com/search?q=flamenco+dance&amp;form=hpcapt&amp;filters=HpDate%3a%2220220216_1830%22&quot;</span>,<br>            <span class="hljs-attr">&quot;drk&quot;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">&quot;enddate&quot;</span>: <span class="hljs-string">&quot;20220217&quot;</span>,<br>            <span class="hljs-attr">&quot;fullstartdate&quot;</span>: <span class="hljs-string">&quot;202202161830&quot;</span>,<br>            <span class="hljs-attr">&quot;hs&quot;</span>: [],<br>            <span class="hljs-attr">&quot;hsh&quot;</span>: <span class="hljs-string">&quot;6c3f5fff2e9235dd83cbc3e5353c5263&quot;</span>,<br>            <span class="hljs-attr">&quot;quiz&quot;</span>: <span class="hljs-string">&quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20220216_FlamencoDance%22&amp;FORM=HPQUIZ&quot;</span>,<br>            <span class="hljs-attr">&quot;startdate&quot;</span>: <span class="hljs-string">&quot;20220216&quot;</span>,<br>            <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;The art of flamenco&quot;</span>,<br>            <span class="hljs-attr">&quot;top&quot;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-attr">&quot;url&quot;</span>: <span class="hljs-string">&quot;/th?id=OHR.FlamencoDance_EN-IN6108897298_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&quot;</span>,<br>            <span class="hljs-attr">&quot;urlbase&quot;</span>: <span class="hljs-string">&quot;/th?id=OHR.FlamencoDance_EN-IN6108897298&quot;</span>,<br>            <span class="hljs-attr">&quot;wp&quot;</span>: <span class="hljs-literal">false</span><br>        &#125;<br>    ],<br>    <span class="hljs-attr">&quot;tooltips&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;loading&quot;</span>: <span class="hljs-string">&quot;Loading...&quot;</span>,<br>        <span class="hljs-attr">&quot;next&quot;</span>: <span class="hljs-string">&quot;Next image&quot;</span>,<br>        <span class="hljs-attr">&quot;previous&quot;</span>: <span class="hljs-string">&quot;Previous image&quot;</span>,<br>        <span class="hljs-attr">&quot;walle&quot;</span>: <span class="hljs-string">&quot;This image is not available to download as wallpaper.&quot;</span>,<br>        <span class="hljs-attr">&quot;walls&quot;</span>: <span class="hljs-string">&quot;Download this image. Use of this image is restricted to wallpaper only.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以看到 images 下的 url 便是我们需要的图片链接。拼接 url 并请求</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> http <span class="hljs-string">&quot;https://www.bing.com/th?id=OHR.FlamencoDance_EN-IN6108897298_1920x1080.jpg&amp;rf=LaDigue_1920x1080.jpg&amp;pid=hp&quot;</span> &gt; wallpapre.jpg</span><br></code></pre></div></td></tr></table></figure><p>就可以得到当前 bing 的壁纸了。到这里我们就理顺了如何获取到图片的流程，接下来就是搭建图片服务了</p><h3 id="服务搭建"><a href="#服务搭建" class="headerlink" title="服务搭建"></a>服务搭建</h3><p>如果从零开始，购买服务器并搭建图片服务，对于我需求来说做的额外工作是在是太多了。</p><p>于是我使用<a href="https://workers.cloudflare.com/"> cloudflare woker</a>， 使用 woker 不仅可以快速的搭建一个免费的服务，并且还可以获得一个域名。</p><p>cloudflare 的免费账号的每日请求数也足够使用了，本着能省一点是一点的原则，我选择了它。</p><p>首先是注册一个 cloudflare 的账号，并完成响应的设置。</p><p>然后就是构建一个 woker 了，在 woker 的 <a href="https://dash.cloudflare.com/3ebe93d1a2f956916b44850bff6cf618/workers/overview">dashbord</a> 选择 <strong>创建服务</strong>，定好名称，我的名字是 wallpaper，选择默认的启动器即可，点击创建服务即可。</p><p>完成服务的创建之后，选中你的 woker，点击快速编辑，将触发器的代码填入，点击保存并部署。</p><p>触发器代码：</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">addEventListener(<span class="hljs-string">&quot;fetch&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>  event.respondWith(<br>    handleRequest(event.request).catch(<br>      <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-keyword">new</span> Response(err.stack, &#123; <span class="hljs-attr">status</span>: <span class="hljs-number">500</span> &#125;)<br>    )<br>  );<br>&#125;);<br><br><span class="hljs-keyword">const</span> base = <span class="hljs-string">&quot;http://www.bing.com&quot;</span><br><span class="hljs-keyword">const</span> statusCode = <span class="hljs-number">302</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&quot;http://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=en-US&quot;</span>)<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> resp.json()<br>  <span class="hljs-keyword">const</span> image = data[<span class="hljs-string">&quot;images&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;url&quot;</span>]<br>  <span class="hljs-keyword">const</span> destinationURL = base + image<br>  <span class="hljs-keyword">return</span> Response.redirect(destinationURL, statusCode)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这样，服务就部署完成了，在浏览器输入服务的地址，就可以看到图片的展示效果了。</p><p>总共花费半天时间，0 ¥。</p>]]></content>
    
    
    
    <tags>
      
      <tag>serverless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Go 没有引用值</title>
    <link href="/post/go-has-no-refrence-value.html"/>
    <url>/post/go-has-no-refrence-value.html</url>
    
    <content type="html"><![CDATA[<p>在别的一些语言中，调用函数时，有传值以及传引用的区别，但是在 Go 中，没有传引用这样的说法。</p><p>Go 只有传值，Go 只有传值，Go 只有传值！！！</p><p>重要的事情说三遍。因此对于函数传参来说传入的值会被复制</p><ul><li>对于基本类型来说，会直接复制相应的值传入其中</li><li>对于自自定义的结构体，也会复制然后传入其中</li><li>对于指针，会复制一个新的指针，指向原指针的值，因此传入指针可以修改原有的值</li><li>对于 map/slice/chan 来说，他们是内置的特殊结构体，内部包含了指向底层数据的指针，因此传入 map/slice/chan 可以修改原有的值</li><li>对于 array 来说，会复制产生一个新的 array，因此如果需要在函数中修改原有数组中的值，需要传入一个 array 指针。因为 array 的特殊性, <a href="https://go.dev/doc/effective_go#arrays">相关博客</a></li></ul><p>归纳为一句话：在 Go 中所有值赋值，包括参数传递等，都是<strong>浅值复制</strong>（指针指向的值不会被复制）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 单例模式</title>
    <link href="/post/golang-singleton-parttern.html"/>
    <url>/post/golang-singleton-parttern.html</url>
    
    <content type="html"><![CDATA[<p>单例模式是一种最基本的设计模式，属于创造模式的一种。在应用了单例模式的时候，类的实例在全局中只会存在一个。实例也只会被创建一次。通常用于系统只需要拥有一个全局对象的时候。例如数据库连接对象。</p><p>单例模式分为懒汉和饿汉模式两种。</p><p>首先是饿汉模式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *object = &amp;object&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span> *<span class="hljs-title">object</span></span> &#123;<br><span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在包初始化的过程中就完成了对象的初始化工作，然后调用函数直接返回实例对象即可。</p><p>但是由于是在导入包的过程中初始化对象，会造成加载时间过长。</p><p>然后就是懒汉模式，懒汉模式是在实际调用时才会去创建对象的实例。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *object<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span> *<span class="hljs-title">object</span></span> &#123;<br>    <span class="hljs-keyword">if</span> instance == <span class="hljs-literal">nil</span> &#123;<br>        instance = &amp;object&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在判断实例变量为<code>nil</code>时，才会去创建对象。但是直接这样写会带来并发上的问题。如果多个 goroutine 调用方法，会创建出多个实例来。因此为了保障并发安全，可以对其中的逻辑进行加锁的操作。</p><p>但是在 Go 中还有另外的一种方式，那就是借助 <code>once.Do</code> 来实现</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> object <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> (<br>  instance *object<br>  once sync.Once<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetObject</span><span class="hljs-params">()</span> *<span class="hljs-title">object</span></span> &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>      instance = &amp;object&#123;&#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 Once.Do，既保证了对象会被初始化一次，也保证了并发下只创建一个对象。</p><p>因此，如果需要在 Go 中应用单例模式，那么最好的选择就是使用 Once.Do 方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在云主机上安装 k3s</title>
    <link href="/post/install-k3s-on-cloud-instance.html"/>
    <url>/post/install-k3s-on-cloud-instance.html</url>
    
    <content type="html"><![CDATA[<p>K3s 是一个轻量化的 Kubernetes 集群软件，专门针对 IoT 和边缘计算(Edge computing)设备开发的，适合低配置硬件的设备上使用。</p><p>可以用于在低配置的云主机上进行部署。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 k3s 只需要一条命令即可</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=<span class="hljs-string">&quot;644&quot;</span> sh -s -</span><br></code></pre></div></td></tr></table></figure><p>K3S_KUBECONFIG_MODE 是为了避免在宿主机上使用 kubectl 命令时遇到权限问题。</p><p>但是如果是在云主机上安装，如果公网 IP 没有绑定到主机上，用 ifconfig 无法看到，那么就需要添加如下的命令，否则无法从公网通过config 文件访问到集群</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl -sLS https://get.k3s.io | K3S_KUBECONFIG_MODE=&quot;644&quot; INSTALL_K3S_EXEC=&#x27;server --tls-san x.x.x.x&#x27; sh -<br></code></pre></div></td></tr></table></figure><p><code>x.x.x.x</code>为云主机的公网IP。</p><p>完成后将配置文件拷贝到本机即可</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> scp x.x.x.x:/etc/rancher/k3s/k3s.yaml ~/.kube/</span><br></code></pre></div></td></tr></table></figure><p>修改 k3s.yaml </p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <span class="hljs-string">https://x.x.x.x:6443</span><br></code></pre></div></td></tr></table></figure><p>完成后测试</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> KUBECONFIG=~/.kube/k3s.yaml</span><br><span class="hljs-meta">$</span><span class="bash"> kubectl get nodes</span><br></code></pre></div></td></tr></table></figure><h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p>如果服务器对于下载链接的访问有问题，可以通过离线安装的方式进行安装</p><p>首先下载需要的可执行文件，<a href="https://github.com/rancher/k3s/releases">下载地址</a></p><p>然后下载安装脚本：<a href="https://get.k3s.io](https://get.k3s.io/)">https://get.k3s.io](https://get.k3s.io/)</a> </p><p>将二进制文件放在每个节点的<code>/usr/local/bin</code>中，并确保拥有可执行权限。将安装脚本放在每个节点的任意位置，并将其命名为<code>install.sh</code></p><p>最后执行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">INSTALL_K3S_SKIP_DOWNLOAD=true ./install.sh<br></code></pre></div></td></tr></table></figure><h2 id="添加-woker-节点"><a href="#添加-woker-节点" class="headerlink" title="添加 woker 节点"></a>添加 woker 节点</h2><p>如果需要添加额外的 worker 节点到集群，只需要添加 <code>K3S_TOKEN</code> 即可。</p><p>在 master 节点上查看 token</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat  /var/lib/rancher/k3s/server/node-token</span><br></code></pre></div></td></tr></table></figure><p> 然后在需要添加的 woker 节点上输入如下的命令即可</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> curl -sfL https://get.k3s.io | K3S_URL=https://myserver:6443 K3S_TOKEN=mynodetoken sh -</span><br></code></pre></div></td></tr></table></figure><p>添加完成后，查看所有节点状态。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl get nodes</span><br></code></pre></div></td></tr></table></figure><p>默认情况下新增的节点角色为 <code>none</code>, 可以通过 <code>kubectl</code>为节点添加角色</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> kubectl label nodes &lt;nodes-name&gt; kubernetes.io/role=worke</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 的时间格式</title>
    <link href="/post/time-format-of-go.html"/>
    <url>/post/time-format-of-go.html</url>
    
    <content type="html"><![CDATA[<p>在 Go 中如果你需要解析一个自定义的时间字符串，将其转化为 Go 的 <code>time.Time</code> 类型，或者格式化的输出时间，那么你需要定义一个 layout。</p><p>在这一步就会容易出现错误，不同于其他语言以形如 <code>yyyy-MM-dd HH:mm:ss</code> 的格式解析，Go 是以一个特定的时间来确定格式, 即 **<code>2006-01-02T15:04:05Z07:00</code>**。</p><p>因此，如果你需要使用 Go 来解析一个时间字符串， 那么你可能就需要写如下的代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br>fmt.Println(t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>t, err := time.Parse(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="hljs-string">&quot;2019-01-01 12:00:00&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err.Error())<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>&#125;<br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// 2021-12-14 16:46:19</span><br><span class="hljs-comment">// 2019-01-01 12:00:00</span><br></code></pre></div></td></tr></table></figure><p>在 Go 中，时间的格式都是 <code>20060102150405</code> 的格式变种。</p><p>那么看到这里，肯定会觉得奇怪，为什么 Go 会选用这样的一个时间来作为格式化的标准。</p><p>实际上，这个时间中的<code>0 1 2 3 4 5 6</code>对应了 Posix 下 date 命令的输出</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Mon Jan 2 15:04:05 -0700 MST 2006<br>0   1   2  3  4  5              6<br></code></pre></div></td></tr></table></figure><p><code>7</code> 对应的就是中间的时区。</p><p>因此想要转化时间不出错，需要记住这个时间点，也就是星期，月，日，时，分，秒，年的，从 0 递增的一个序列。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 配置 HTTP Basic Auth</title>
    <link href="/post/nginx-basic-auth.html"/>
    <url>/post/nginx-basic-auth.html</url>
    
    <content type="html"><![CDATA[<p>Nginx 是一个被广泛使用的 Web 服务器，代理服务器。本文主要介绍如何为 Nginx 配置 HTTP Basic Auth。(演示环境为 macOS)</p><p>Basic Auth 是一个非常简单的认证方式，在请求的 Header 中会包含<code>Authorization</code>字段，形式如下： <code>Authorization: Basic &lt;凭证&gt;</code>，该凭证是用户和密码的组和的 base64 编码。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>在开始之前需要准备好环境，如果在直接在本机安装，可能会与已有的服务冲突，为了方便起见，在 docker 中运行 nginx来进行实验。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker pull nginx:latest</span><br></code></pre></div></td></tr></table></figure><h3 id="配置-HTTP-Basic-Auth-证书"><a href="#配置-HTTP-Basic-Auth-证书" class="headerlink" title="配置 HTTP Basic Auth 证书"></a>配置 HTTP Basic Auth 证书</h3><p>在这一步我们将会为站点创建用户名密码。</p><p>存储用户名密码的文件会由我们指定好，直接在当前目录下创建 <code>test.htpasswd</code>文件，并且将用户名设置为 <code>nginx</code>。</p><p>运行下面的命令，来配置密码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> htpasswd -c test.htpasswd nginx</span><br></code></pre></div></td></tr></table></figure><p>完成后，可以查看文件的内容来确定配置成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat test.htpasswd</span><br>nginx:$apr1$9Pn6zJkQ$PcOGDRG/i.mpLn8jCEYui.<br></code></pre></div></td></tr></table></figure><h3 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h3><p>完成用户名密码的配置后，需要对 nginx 的配置文件进行修改，在当前目录创建一个 default.conf 配置文件，并在之后挂载到容器内。</p><p>拷贝一份配置文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run --rm -d --name nginx nginx</span><br><span class="hljs-meta">$</span><span class="bash"> docker cp nginx:/etc/nginx/conf.d/default.conf  .</span><br><span class="hljs-meta">$</span><span class="bash"> docker stop nginx</span><br></code></pre></div></td></tr></table></figure><p>使用编辑器修改配置文件，添加 auth_basic</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs NGINX">...<br><span class="hljs-attribute">server_name</span> localhost;<br><br><span class="hljs-attribute">location</span> / &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br> <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-attribute">auth_basic</span> <span class="hljs-string">&quot;Private Property&quot;</span>;<br>        <span class="hljs-comment"># 指定配置文件</span><br>        <span class="hljs-attribute">auth_basic_user_file</span> /etc/nginx/.htpasswd;<br>&#125;<br>...<br></code></pre></div></td></tr></table></figure><h3 id="测试配置"><a href="#测试配置" class="headerlink" title="测试配置"></a>测试配置</h3><p>启动容器，并测试我们的配置是否成功</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run --rm -d -p 8080:80 --name nginx -v <span class="hljs-variable">$PWD</span>/test.htpasswd:/etc/nginx/.htpasswd -v  <span class="hljs-variable">$PWD</span>/default.conf:/etc/nginx/conf.d/default.conf nginx</span><br></code></pre></div></td></tr></table></figure><p>打开浏览器，输入<a href="http://localhost:8080/">http://localhost:8080</a> 就可以看到，网页提示我们输入用户名密码了，输入正确的用户名密码后，才能看到欢迎页。</p><p>到此，为 nginx 配置 basic auth 就完成了。更多的配置可以参考 <a href="https://docs.nginx.com/">Nginx 官方文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 20.04 安装 Podman</title>
    <link href="/post/install-podman-on-unbunutu-20.04.html"/>
    <url>/post/install-podman-on-unbunutu-20.04.html</url>
    
    <content type="html"><![CDATA[<p>Podman 是一款用于开发运行测试容器和镜像的工具，不同于 Docker，他不需要 root 权限就可以运行。同时 Docker 需要 Docker Engine 以 Daemon 的形式运行，而 Podman 则不需要。</p><p>这篇文章介绍如何在 Ubuntu 20.04 上安装 Podman</p><p>在安装 Podman 之前需要安装依赖工具</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt update</span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt install curl wget gnupg2 -y</span><br></code></pre></div></td></tr></table></figure><p>接下来就是添加 Podman 的仓库源, 添加 GPG 的 key</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">source</span> /etc/os-release</span><br><span class="hljs-meta">$</span><span class="bash"> sudo sh -c <span class="hljs-string">&quot;echo &#x27;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/xUbuntu_<span class="hljs-variable">$&#123;VERSION_ID&#125;</span>/ /&#x27; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/xUbuntu_<span class="hljs-variable">$&#123;VERSION_ID&#125;</span>/Release.key -O- | sudo apt-key add -</span><br></code></pre></div></td></tr></table></figure><p>完成上述配置后就可以更新并安装了</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo apt-get update</span><br><span class="hljs-meta">$</span><span class="bash"> sudo apt-get install -y podman</span><br></code></pre></div></td></tr></table></figure><p>安装完成后就可以确定一下状态了</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> podman --version</span><br><span class="hljs-meta">$</span><span class="bash"> podman info</span><br></code></pre></div></td></tr></table></figure><p>这样就可以完成在 Ubuntu 20.04 上安装 podman 了。接下里就可以愉快的与 Podman 玩耍了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 nvim</title>
    <link href="/post/setup-nvim.html"/>
    <url>/post/setup-nvim.html</url>
    
    <content type="html"><![CDATA[<p>手贱修改了一次电脑的配置，导致之前的 vim 重装，并丢失了相关的配置，本文记录一下重现安装并且配置的过程，作为备忘，在下次遇到相关的问题时，可以更快的恢复。</p><p>首先是安装 neovim，这里不选择 vim 的原因是听网上的推荐， neovim 更为现代化一点，所以尝试使用 neovim 替代 vim。</p><p>直接通过 <code>brew</code> 安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew install neovim</span><br></code></pre></div></td></tr></table></figure><p>键入 nvim 就可以使用了，不想每次都输入 nvim，于是在 <code>.zshrc</code> 下添加一个 alias</p><figure class="highlight zsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh"><span class="hljs-built_in">alias</span> vim=<span class="hljs-string">&quot;nvim&quot;</span><br></code></pre></div></td></tr></table></figure><p>这样所有的 vim 都实际上使用的是 nvim 了。</p><p>接下来就是配置 nvim.</p><h2 id="1-创建配置文件"><a href="#1-创建配置文件" class="headerlink" title="1. 创建配置文件"></a>1. 创建配置文件</h2><p>nvim 的默认配置文件是 <code>~/.config/nvim/init.vim</code>, 如果目录不存在，需要新建目录,  并且创建文件</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir -p  ~/.config/nvim/</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;set nu&quot;</span> &gt; ~/.config/nvim/init.vim</span><br></code></pre></div></td></tr></table></figure><p>添加最基本的配置，显示行号。然后就是插件的安装了</p><h2 id="2-配置插件"><a href="#2-配置插件" class="headerlink" title="2. 配置插件"></a>2. 配置插件</h2><p>依托于丰富的插件，vim 可以获得媲美 IDE 的体验，在安装插件之前，首先需要先安装好插件管理器来帮助我们管理 vim 的插件。</p><p>首先安装 <code>pynvim</code>, 来支持 python 书写的插件.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">pip install --user --upgrade pynvim<br></code></pre></div></td></tr></table></figure><p>插件管理器选用 <a href="https://github.com/junegunn/vim-plug.git">vim-plug</a>，路径是 <code>&quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim</code>.</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sh -c &#x27;curl -fLo &quot;$&#123;XDG_DATA_HOME:-$HOME/.local/share&#125;&quot;/nvim/site/autoload/plug.vim --create-dirs \<br>       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim&#x27;<br></code></pre></div></td></tr></table></figure><p>完成之后就可以开始安装所需要的插件了，编辑 <code>~/.config/nvim/init.vim</code> 文件，新增如下的内容</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-comment">&quot; 指定插件的安装位置</span><br><span class="hljs-keyword">call</span> plug#begin(<span class="hljs-string">&#x27;~/.vim/plugged&#x27;</span>)<br><br><br><span class="hljs-comment">&quot; 插件引入的形式为 Plug &#x27;plugin-url&#x27;</span><br><span class="hljs-comment">&quot; 使用单引号包裹路径，双引号会被视作注释</span><br><span class="hljs-comment">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span><br>Plug <span class="hljs-string">&#x27;junegunn/vim-easy-align&#x27;</span><br><br><span class="hljs-comment">&quot; Any valid git URL is allowed</span><br>Plug <span class="hljs-string">&#x27;https://github.com/junegunn/vim-github-dashboard.git&#x27;</span><br><br><span class="hljs-comment">&quot; Multiple Plug commands can be written in a single line using | separators</span><br>Plug <span class="hljs-string">&#x27;SirVer/ultisnips&#x27;</span> | Plug <span class="hljs-string">&#x27;honza/vim-snippets&#x27;</span><br><br><span class="hljs-comment">&quot; On-demand loading</span><br>Plug <span class="hljs-string">&#x27;scrooloose/nerdtree&#x27;</span>, &#123; <span class="hljs-string">&#x27;on&#x27;</span>:  <span class="hljs-string">&#x27;NERDTreeToggle&#x27;</span> &#125;<br>Plug <span class="hljs-string">&#x27;tpope/vim-fireplace&#x27;</span>, &#123; <span class="hljs-string">&#x27;for&#x27;</span>: <span class="hljs-string">&#x27;clojure&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Using a non-default branch</span><br>Plug <span class="hljs-string">&#x27;rdnetto/YCM-Generator&#x27;</span>, &#123; <span class="hljs-string">&#x27;branch&#x27;</span>: <span class="hljs-string">&#x27;stable&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br>Plug <span class="hljs-string">&#x27;fatih/vim-go&#x27;</span>, &#123; <span class="hljs-string">&#x27;tag&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Plugin options</span><br>Plug <span class="hljs-string">&#x27;nsf/gocode&#x27;</span>, &#123; <span class="hljs-string">&#x27;tag&#x27;</span>: <span class="hljs-string">&#x27;v.20150303&#x27;</span>, <span class="hljs-string">&#x27;rtp&#x27;</span>: <span class="hljs-string">&#x27;vim&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Plugin outside ~/.vim/plugged with post-update hook</span><br>Plug <span class="hljs-string">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class="hljs-string">&#x27;dir&#x27;</span>: <span class="hljs-string">&#x27;~/.fzf&#x27;</span>, <span class="hljs-string">&#x27;do&#x27;</span>: <span class="hljs-string">&#x27;./install --all&#x27;</span> &#125;<br><br><span class="hljs-comment">&quot; Unmanaged plugin (manually installed and updated)</span><br>Plug <span class="hljs-string">&#x27;~/my-prototype-plugin&#x27;</span><br><br>Plug <span class="hljs-string">&#x27;altercation/vim-colors-solarized&#x27;</span><br><br><span class="hljs-keyword">call</span> plug#end()<br></code></pre></div></td></tr></table></figure><p>然后输入 <code>PlugInstall</code> 命令，就会自动下载安装指定的插件了.</p><p> 删除插件只需要移除对应的插件声明，在运行 <code>PlugClean</code> 命令即可.</p><h2 id="3-优化配置"><a href="#3-优化配置" class="headerlink" title="3. 优化配置"></a>3. 优化配置</h2><p>设置主题</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> background=dark<br><span class="hljs-keyword">colorscheme</span> solarized<br></code></pre></div></td></tr></table></figure><p>设置 NerdTree</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">map</span> <span class="hljs-symbol">&lt;F10&gt;</span> :NERDTreeToggle<span class="hljs-symbol">&lt;CR&gt;</span><br><span class="hljs-keyword">nmap</span> <span class="hljs-symbol">&lt;M-m&gt;</span> :NERDTreeFind<span class="hljs-symbol">&lt;CR&gt;</span><br><br><span class="hljs-keyword">let</span> NERDTreeShowLineNumbers=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> NERDTreeAutoCenter=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> NERDTreeShowHidden=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">let</span> NERDTreeIgnore=[<span class="hljs-string">&#x27;\.pyc&#x27;</span>,<span class="hljs-string">&#x27;\~$&#x27;</span>,<span class="hljs-string">&#x27;\.swp&#x27;</span>]<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:nerdtree_tabs_open_on_console_startup</span>=<span class="hljs-number">1</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:NERDTreeGitStatusIndicatorMapCustom</span> = &#123;<br>    \ <span class="hljs-string">&quot;Modified&quot;</span>  : <span class="hljs-string">&quot;✹&quot;</span>,<br>    \ <span class="hljs-string">&quot;Staged&quot;</span>    : <span class="hljs-string">&quot;✚&quot;</span>,<br>    \ <span class="hljs-string">&quot;Untracked&quot;</span> : <span class="hljs-string">&quot;✭&quot;</span>,<br>    \ <span class="hljs-string">&quot;Renamed&quot;</span>   : <span class="hljs-string">&quot;➜&quot;</span>,<br>    \ <span class="hljs-string">&quot;Unmerged&quot;</span>  : <span class="hljs-string">&quot;═&quot;</span>,<br>    \ <span class="hljs-string">&quot;Deleted&quot;</span>   : <span class="hljs-string">&quot;✖&quot;</span>,<br>    \ <span class="hljs-string">&quot;Dirty&quot;</span>     : <span class="hljs-string">&quot;✗&quot;</span>,<br>    \ <span class="hljs-string">&quot;Clean&quot;</span>     : <span class="hljs-string">&quot;✔︎&quot;</span>,<br>    \ <span class="hljs-string">&#x27;Ignored&#x27;</span>   : <span class="hljs-string">&#x27;☒&#x27;</span>,<br>    \ <span class="hljs-string">&quot;Unknown&quot;</span>   : <span class="hljs-string">&quot;?&quot;</span><br>    \ &#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">g:NERDTreeGitStatusShowIgnored</span>= <span class="hljs-number">1</span><br><span class="hljs-keyword">nmap</span> <span class="hljs-symbol">&lt;Leader&gt;</span><span class="hljs-keyword">pwd</span> :NERDTreeCWD<span class="hljs-symbol">&lt;CR&gt;</span><br></code></pre></div></td></tr></table></figure><p>到这里就完成了基本的配置了，如果之后需要进一步的配置，就需要自己安装或者写一下插件，并且配置了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为何需要 Helm</title>
    <link href="/post/why-need-helm.html"/>
    <url>/post/why-need-helm.html</url>
    
    <content type="html"><![CDATA[<p>Kubernetes 在容器编排领域已经成为事实上的标准，一款云原生应用在开发周期的最后阶段都是会被部署到 k8s 集群之上。</p><p>部署在 k8s 上的应用在免去了拓展，迁移，服务发现等一系列工作的同时，也带来了其他的问题。</p><p>由于 Kubernetes 的资源都是声明式的，这意味着如果想要部署一款新的应用，那么就需要围绕应用所需的资源，以及其的元信息编写对应的 yaml 文件，包括不限于 service，deployment，configmap，secret 的资源定义。</p><p>如果是一款简单的应用还好，但是一旦应用比较复杂，依赖的资源比较多，那么编写资源文件就是一个痛苦的过程了，而且往往不是开发人员独自能够完成的，还需要和运维人员进行配合。</p><p>除此之外，每次升级应用，都需要一系列的工作，并且如果需要回滚应用的版本，那么就更加会运维开发人员感到痛苦了。</p><p>因此，为了解决这些问题，我们就需要 helm 来帮我们完成一些重复性的工作，根据模版来生成我们所需要的资源文件。</p><h2 id="helm"><a href="#helm" class="headerlink" title="helm"></a>helm</h2><p>helm 是一个Kubernetes 应用打包，管理工具。每个 kubernetes 上的应用被称之为一个 helm chart。</p><p>使用 helm 可以帮助我们来定义，升级，发布以及回滚应用。而不需要每次都复制粘贴，然后再修改。</p><p>如果将 Kubernetes 看作为一个操作系统话，那么 helm 就是系统的软件管理器，也可以将其看作是一个 APP store。</p><p>通过修改 helm 生成的模版值，完成应用的打包，之后就可以将应用推送到不同的仓库。在需要安装应用的集群上只需要运行 helm upgrade 就可以完成安装了。免去了一堆的烦恼。</p><h2 id="helm-的一些概念"><a href="#helm-的一些概念" class="headerlink" title="helm 的一些概念"></a>helm 的一些概念</h2><h3 id="Chart"><a href="#Chart" class="headerlink" title="Chart"></a><em>Chart</em></h3><p>Chart 是 helm 的打包格式，它有一系列相关的 Kubernetes 资源文件组成。每个 chart 都相当于一个应用，不论是一个简单的单 pod 应用，还是一个包含多个服务，以及数据库，缓存等功能的复杂应用。</p><p>当完成资源文件的配置之后，就可以发布新版本的应用了。</p><p>chart 的文件结构</p><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">wordpress/<br>  Chart.yaml          <span class="hljs-comment"># A YAML file containing information about the chart</span><br>  LICENSE             <span class="hljs-comment"># OPTIONAL: A plain text file containing the license for the chart</span><br>  README.md           <span class="hljs-comment"># OPTIONAL: A human-readable README file</span><br>  values.yaml         <span class="hljs-comment"># The default configuration values for this chart</span><br>  values.schema.json  <span class="hljs-comment"># OPTIONAL: A JSON Schema for imposing a structure on the values.yaml file</span><br>  charts/             <span class="hljs-comment"># A directory containing any charts upon which this chart depends.</span><br>  crds/               <span class="hljs-comment"># Custom Resource Definitions</span><br>  templates/          <span class="hljs-comment"># A directory of templates that, when combined with values,</span><br>                      <span class="hljs-comment"># will generate valid Kubernetes manifest files.</span><br>  templates/NOTES.txt <span class="hljs-comment"># OPTIONAL: A plain text file containing short usage notes</span><br></code></pre></div></td></tr></table></figure><p>每个 chart 都需要有对应的版本号。例如：<code>nginx-1.2.3.tgz</code> 代表这是一个 1.2.3 版本的 nginx 应用。</p><h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a><em>Repository</em></h3><p>Repository 是一个存放，分享 chart 的地方。在完成指定版本的 chart 后，可以将其推送到指定的 repository 中，其他需要使用的人就可以从对应的 repository 拉取到想要的 chart 并启动。</p><h3 id="Release"><a href="#Release" class="headerlink" title="Release"></a><em>Release</em></h3><p>Release 是一个运行在 Kubernetes 上的 chart 的实例。chart 是可以在集群上多次安装的，每次安装一个 chart 都会产生一个 release。</p><p>同样的，如果需要两个实例同时运行，那么只需要安装 chart 两次即可，这样集群上就会有两个 release，并且每个 release 都有着自己的名字。</p><p>以面向对象的思想来看的话，chart 就是一个类，而 release 就是 chart 的实例对象。</p><p>以上就是关于为什么需要 helm 以及 helm 的基本概念，需要了解更多的信息可以阅读<a href="https://helm.sh/docs/">官方文档</a>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 Mac 上安装数据库</title>
    <link href="/post/install-database-on-mac.html"/>
    <url>/post/install-database-on-mac.html</url>
    
    <content type="html"><![CDATA[<p>在日常的开发过程中，通常需要使用到数据库。</p><p>在本地安装开发用的数据库有两种做法，一是使用 docker 起一个 container，二是直接安装数据库服务。</p><p>对于容器来说，优点在于可以快速的启动服务，并且在使用后清理干净，但是在 Mac 上使用 docker 会有文件效率的影响，并且在 Apple silicon 的 docker 只能使用 arm 架构的镜像，因此可以选择直接安装对应的数据库服务。</p><p>借助于 <code>homebrew</code> 可以快速的安装原生的服务。</p><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>安装 mysql 只需键入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew install mysql</span><br></code></pre></div></td></tr></table></figure><p>然后等待安装完成。需要的时间可能会稍微长一点，因为 homebrew 会从源码编译。</p><p>安装完成后就可以启动 mysql 了，完成安全安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew services start mysql</span><br><span class="hljs-meta">$</span><span class="bash"> mysql_secure_installation</span> <br></code></pre></div></td></tr></table></figure><p>默认状态下，mysql 只绑定在 127.0.0.1，需要修改设置，配置文件在 <code>/opt/homebrew/etc/my.cnf</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat /opt/homebrew/etc/my.cnf</span><br><span class="hljs-meta">#</span><span class="bash"> Default Homebrew MySQL server config</span><br>[mysqld]<br><span class="hljs-meta">#</span><span class="bash"> Only allow connections from localhost</span><br>bind-address = 127.0.0.1<br>mysqlx-bind-address = 127.0.0.1<br></code></pre></div></td></tr></table></figure><p>将 <code>bind-address = 127.0.0.1</code> 改为 <code>bind-address = 0.0.0.0</code></p><p>允许 root 从任何 host</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">UPDATE mysql.user SET Host=&#x27;%&#x27; WHERE Host=&#x27;localhost&#x27; AND User=&#x27;username&#x27;;<br>FLUSH PRIVILEGES;<br></code></pre></div></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> brew install redis</span><br><span class="hljs-meta">$</span><span class="bash"> brew services start redis</span><br></code></pre></div></td></tr></table></figure><p>测试服务是否在运行, 返回 PONG 则说明服务正常运行</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> redis-cli ping</span><br></code></pre></div></td></tr></table></figure><p>修改配置文件 <code>/opt/homebrew/etc/redis.conf</code></p><p>一些 redis 的快速命令</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除所有数据库里的所有 key</span><br><span class="hljs-meta">$</span><span class="bash"> redis-cli FLUSHALL</span><br><span class="hljs-meta">#</span><span class="bash"> 删除当前数据库的所有 key</span><br><span class="hljs-meta">$</span><span class="bash"> redis-cli FLUSHDB</span><br><span class="hljs-meta">#</span><span class="bash"> 删除指定数据库的所有 key</span><br><span class="hljs-meta">$</span><span class="bash"> redis-cli -n &lt;database_number&gt; FLUSHDB</span><br><span class="hljs-meta">#</span><span class="bash"> 获取当前数据库所有 key</span><br><span class="hljs-meta">$</span><span class="bash"> redis-cli keys <span class="hljs-string">&quot;*&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> 获取指定数据库的所有 key</span><br><span class="hljs-meta">$</span><span class="bash"> redis-cli -n &lt;database_number&gt; keys <span class="hljs-string">&quot;*&quot;</span></span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初始化 Go 项目</title>
    <link href="/post/go-project-setup.html"/>
    <url>/post/go-project-setup.html</url>
    
    <content type="html"><![CDATA[<h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>初始化一个 Go web 项目的步骤。</p><p>首先是创建项目的的文件夹，并初始化 <code>go.mod</code>,  假设项目的远端地址为 <code>github.com/someone/someproject.git</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ mkdir PROJECT_NAME<br>$ <span class="hljs-built_in">cd</span> PROJECT_NAME<br>$ go mod init github.com/someone/someproject<br></code></pre></div></td></tr></table></figure><p>项目的布局结构可以参考 <a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a></p><h2 id="配置-makefile"><a href="#配置-makefile" class="headerlink" title="配置 makefile"></a>配置 makefile</h2><p>这样就完成了项目的第一步，接下来就是配置一些项目构建的脚本，一般都是使用 <code>makefile</code> 来作为项目的管理方式。下面是一个常见的makefile 配置</p><p>首先是帮助信息，通过输入 make help 获取到当前 makefile 的 target 和用法</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">## help: Show help message</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: help</span><br><span class="hljs-section">help: Makefile</span><br>@echo <span class="hljs-string">&quot;\nUsage: make &lt;TARGETS&gt;&quot;</span><br>@sed -n &#x27;s/^<span class="hljs-comment">##//p&#x27; $&lt; | column -t -s &#x27;:&#x27; | sed -e &#x27;s/^/ /&#x27;</span><br></code></pre></div></td></tr></table></figure><p>然后是常用的编译，测试命令</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">## build: build the project</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: build</span><br><span class="hljs-section">build:</span><br>@go build cmd/main.go<br><br><span class="hljs-comment">## test: run tests</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: test</span><br><span class="hljs-section">test:</span><br>@go test -v  ./...<br></code></pre></div></td></tr></table></figure><p>如果项目需要用到第三方的 go 工具，可以项目中加上类似下面的脚本</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">## go.install.swag: install swag</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: go.install.swag</span><br><span class="hljs-section">go.install.swag:</span><br>@go install github.com/swaggo/swag/cmd/swag@latest<br></code></pre></div></td></tr></table></figure><h2 id="配置-swagger"><a href="#配置-swagger" class="headerlink" title="配置 swagger"></a>配置 swagger</h2><p>通常来说，接口的文档管理可以通过 swagger 来做，如果使用 gin 框架来做 web，那么就可以使用 <a href="https://github.com/swaggo/gin-swagger">gin- swagger</a>.</p><p> 下载安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go get -u github.com/swaggo/gin-swagger</span><br><span class="hljs-meta">$</span><span class="bash"> go get -u github.com/swaggo/files</span><br></code></pre></div></td></tr></table></figure><p>然后在路由注册处，注册 gin-swagger 的路由</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">r.GET(<span class="hljs-string">&quot;/swagger/*any&quot;</span>, ginSwagger.WrapHandler(swaggerfiles.Handler))<br></code></pre></div></td></tr></table></figure><p>同时需要在主入口处引入文档所在目录，并且添加对应的注释，具体可参见官方文档。</p><p>完成上述的基本配置之后，一个项目的框架就算是初步搭建完成了，之后就可以进行业务代码的书写了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 运行时镜像时区问题</title>
    <link href="/post/go-runtime-image-timezone.html"/>
    <url>/post/go-runtime-image-timezone.html</url>
    
    <content type="html"><![CDATA[<p>本文主要介绍 Go 程序设置时间戳计算时间时需要注意的问题，以及如何在产出的 Go 服务镜像中设置正确的文件。</p><p>在修复一个时间相关的 bug 后，部署新服务时出现了如下的错误</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">could not load time location: unknown time zone Asia/Shanghai<br></code></pre></div></td></tr></table></figure><p>系统报错显示无法加载 time zone，但是这段程序在本地运行是正常的。于是开始了排查之旅。</p><p>为了方便说明，下面是一个简单的程序，获取当前的时间，并且转化为指定时区的时间并输出。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br><br>loc, err := time.LoadLocation(<span class="hljs-string">&quot;UTC&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err.Error())<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Println(t.String())<br>fmt.Println(t.In(loc).String())<br>  <br>  <span class="hljs-comment">// Output:</span><br>  <span class="hljs-comment">// 2021-09-27 14:00:42.181169 +0800 CST m=+0.000100571</span><br>  <span class="hljs-comment">// 2021-09-27 06:00:42.181169 +0000 UTC</span><br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>可以看到，在没有设置时区的时候，输出了当前系统时区的时间，而在设置 Location 之后，就将时间转化为了对应时区的时间。</p><p>但是在这段程序在打包成镜像后，出现了相同的错误。</p><p>原因在于 <code>time.LoadLocation</code> 这个函数。在用户传入合法的时区后， 函数会从下列文件中查找 timezone 信息:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Many systems use /usr/share/zoneinfo, Solaris 2 has</span><br><span class="hljs-comment">// /usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ.</span><br><span class="hljs-keyword">var</span> zoneSources = []<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;/usr/share/zoneinfo/&quot;</span>,<br><span class="hljs-string">&quot;/usr/share/lib/zoneinfo/&quot;</span>,<br><span class="hljs-string">&quot;/usr/lib/locale/TZ/&quot;</span>,<br>runtime.GOROOT() + <span class="hljs-string">&quot;/lib/time/zoneinfo.zip&quot;</span>,<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://github.com/golang/go/blob/54079dfd7fff6c61d41c4832c074e8231f235fc3/src/time/zoneinfo_unix.go#L20">源文件</a></p><p>正常情况下，在本地的开发机上运行是没有问题的，但是如果最终的镜像的基础镜像是 alpine 或者是 busybox，那么就会出现问题，因为在这两个镜像为了体积原因是不会包含这些文件的。</p><p>在明确问题产生的原因后就可以修复了，对于多步构建的镜像来说，只需从上游镜像中拷贝一份时区文件即可。</p><figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment"># Builder</span><br><span class="hljs-string">FROM</span> <span class="hljs-string">golang:latest</span> <span class="hljs-string">AS</span> <span class="hljs-string">builder</span><br><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/server</span><br><br><span class="hljs-string">COPY</span> <span class="hljs-string">.</span> <span class="hljs-string">.</span><br><br><span class="hljs-string">ENV</span> <span class="hljs-string">GOPROXY=&quot;https://goproxy.cn&quot;</span><br><br><span class="hljs-string">RUN</span> <span class="hljs-string">go</span> <span class="hljs-string">build</span><br><br><span class="hljs-comment"># Runtime</span><br><span class="hljs-string">FROM</span> <span class="hljs-string">busybox:glibc</span><br><span class="hljs-string">WORKDIR</span> <span class="hljs-string">/server</span><br><br><span class="hljs-string">COPY</span> <span class="hljs-string">--from=builder</span> <span class="hljs-string">server</span> <span class="hljs-string">.</span><br><span class="hljs-comment"># Copy zoneinfo from builder</span><br><span class="hljs-string">COPY</span> <span class="hljs-string">--from=builder</span> <span class="hljs-string">/usr/share/zoneinfo/</span> <span class="hljs-string">/usr/share/zoneinfo/</span> <br><br><span class="hljs-string">ENTRYPOINT</span> [<span class="hljs-string">&quot;server&quot;</span>]<br><br></code></pre></div></td></tr></table></figure><p>这样修改之后就可以正常部署了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 文件系统层次标准</title>
    <link href="/post/linux-fs-hierarchy-standard.html"/>
    <url>/post/linux-fs-hierarchy-standard.html</url>
    
    <content type="html"><![CDATA[<p>根据<a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs-3.0.html#varlibVariableStateInformation">Linux 标准</a>,  记录下 Linux 文件系统下各个目录的作用，起到备忘的作用。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>首先是关于文件属性的说明，一个文件可以具备如下的两个属性，是否为 <code>static</code> 以及是否为 <code>shareable</code>。两个属性都不相同的文件就不应该放在同一个目录下。</p><p><code>Shareable</code>的文件，即可分享的文件，具有这种属性的文件可以被其他的主机使用，例如家目录下的用户文件。</p><p><code>Unshareable</code>的文件，即不可被分享的文件，具有这种属性的文件是不可以被其他主机所使用的，例如具有设备锁的文件。</p><p><code>Static</code>的文件包括库文件，二进制文件，文档文件以及其他如果没有管理员介入就不会变动的文件。<code>Unstatic</code>的文件则与之相反。</p><p>根据上述的文件属性，可以将文件目录划分为如下的表格：</p><table><thead><tr><th></th><th><strong>shareable</strong></th><th><strong>unshareable</strong></th></tr></thead><tbody><tr><td>static</td><td>/usr</td><td>/etc</td></tr><tr><td></td><td>/opt</td><td>/boot</td></tr><tr><td>unstatic</td><td>/var/mail</td><td>/var/run</td></tr><tr><td></td><td>/var/spool/news</td><td>/var/lock</td></tr></tbody></table><h3 id="目录及描述"><a href="#目录及描述" class="headerlink" title="目录及描述"></a>目录及描述</h3><p>根目录 “/” 下的路径</p><table><thead><tr><th>目录</th><th>描述</th></tr></thead><tbody><tr><td>bin</td><td>基础命令的二进制文件目录</td></tr><tr><td>boot</td><td>boot 时需要的静态文件</td></tr><tr><td>dev</td><td>设备目录</td></tr><tr><td>etc</td><td>特定主机的配置文件</td></tr><tr><td>lib</td><td>基础分享库以及内核模块</td></tr><tr><td>media</td><td>媒体设备的挂载点</td></tr><tr><td>mnt</td><td>文件系统挂载点</td></tr><tr><td>opt</td><td>附加的软件包</td></tr><tr><td>run</td><td>与运行时程序相关的数据</td></tr><tr><td>sbin</td><td>基础系统可执行文件</td></tr><tr><td>srv</td><td>系统提供的服务数据</td></tr><tr><td>tmp</td><td>临时文件目录</td></tr><tr><td>usr</td><td>二级目录</td></tr><tr><td>var</td><td>动态文件</td></tr></tbody></table><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>在 *nix 系统下可以通过 man 命令来查看当前主机的目录与说明</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> man hier</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多生产者关闭 Goroutine</title>
    <link href="/post/close-goroutines.html"/>
    <url>/post/close-goroutines.html</url>
    
    <content type="html"><![CDATA[<p>在本篇文章中，将介绍如何在多个生产者完成生产后关闭 goroutine.</p><p>在编程中，我们会遇到多个生产者，单一消费者的场景。</p><p>在这种情况下，工作流会分为了两个 stage:</p><ul><li>Stage 1: 多个生产者并发地计算结果，并将结果传入 channel</li><li>Stage 2: 消费者从 channel 中读取结果，做下一步的计算</li></ul><p>在两个 stage 完成工作后程序自然退出，因此需要在所有生产者完成工作后，关闭 channel。消费者在 channel 关闭后，结束运行并退出。</p><p>为了保证所有生产者，使用 sync.WaitGroup.</p><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Demo</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>workN := <span class="hljs-number">5</span> <span class="hljs-comment">// 生产者数</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(workN)<br><br><span class="hljs-comment">// stage1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; workN; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br>n := i * i<br>ch &lt;- n<br>wg.Done()<br>&#125;(i)<br>&#125;<br><br><span class="hljs-comment">// close channel</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><br><span class="hljs-comment">// stage 2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先是 stage1，启动多个 Goroutine，通过闭包将 wg 传入，并且在完成任务后调用 wg.Done()。</p><p>然后启动另一个 Goroutine 用来关闭 channel，这个 Goroutine 会阻塞，直到所有的任务完成，最后关闭 channel。</p><p>最后就是 stage2，不停地从 channel 中读取数据，直到 channel 关闭，然后结束程序。</p><p>这样就完成了一个多生产者场景下 channel 关闭的问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 JWT 生成私钥</title>
    <link href="/post/generate-private-key-for-jwt.html"/>
    <url>/post/generate-private-key-for-jwt.html</url>
    
    <content type="html"><![CDATA[<p>今天在写一个登录鉴权的接口，用到了 JWT，JWT 的签名与认证需要用到一对公私钥。所以需要在本地生成一对密钥。</p><p>方法很简单，只需要用到 ssh-keygen 和 openssl 即可，如果命令行下没有这两个工具，可以通过 homebrew 来安装。</p><p>生成的方法代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 首先生成私钥文件，在生成过程中不要输入密码</span><br>ssh-keygen -t rsa -b 4096 -m PEM -f private.key<br><span class="hljs-comment"># 然后根据私钥生成对应的公钥</span><br>openssl rsa -<span class="hljs-keyword">in</span> private.key -pubout -outform PEM -out public.key.pub<br></code></pre></div></td></tr></table></figure><p>完成之后就会在当前文件夹产生两个文件，分别是私钥以及公钥。然后就可以利用它们去签发以及验证 token 了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go append 的小技巧</title>
    <link href="/post/go-append-tip.html"/>
    <url>/post/go-append-tip.html</url>
    
    <content type="html"><![CDATA[<p>在开发的过程中，遇到了一个需要将 T 类型切片映射为 F 类型切片的操作，由于 Go 的标准库中并没有内置 Map 函数，于是就写了一个简单的辅助函数。</p><p>第一版是这样的</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ts = []<span class="hljs-keyword">struct</span> &#123;<br>Foo <span class="hljs-keyword">int</span><br>&#125; &#123;<br>&#123;<br>Foo: <span class="hljs-number">1</span>,<br>&#125;,<br>&#123;<br>Foo: <span class="hljs-number">2</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;)</span> <span class="hljs-title">int</span>) []<span class="hljs-title">int</span></span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result[i] = f(v)<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure><p>先使用 make 初始化了一个长度和容量为 len(ts) 的切片，然后通过 rang ts 获取每个元素对应的索引以及值，然后将它赋予给对应索引的 result。</p><p>到目前为止，这个函数以及满足我的目标了，但是我觉得也可以通过 append 函数来实现。</p><p>在 Go 中，append 做为一个内置函数，作用是向切片的尾部追加元素，并返回新的切片。同时在追加的过程中如果发现切片的容量不够时，就会对切片的底层数组进行扩容。</p><p>于是我修改了一下代码，得到一个新的版本</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;)</span> <span class="hljs-title">int</span>) []<span class="hljs-title">int</span></span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result = <span class="hljs-built_in">append</span>(result, f(v))<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure><p>完成后，当我再跑一次测试时发现结果并不是我想要的，此时的 result 变成了 [0 0 1 2] , 而不是我想要的 [1 2]。</p><p>仔细审视了一下代码，发现问题出在初始化 result 时 make 的调用上。在使用 make 初始化 result 时，我只传入了一个 IntegerType 的参数，即 len(ts)。在这种情况下，make 会返回一个<strong>长度与容量相同</strong>的切片。</p><p>注意，问题就出在长度与容量相同，此时 make 返回给我的是一个具有长度的切片，并且其中的元素都被赋予了零值。因此当我调用 append 往 result 上追加数据时，就会因为容量不足，首先扩容一次，然后再追加新的元素。于是结果就变成了 [0 0 1 2]。</p><p>因此，我需要先初始化一个长度为 0 的切片，然后从一个空切片开始追加元素，这样就可以达到我的目标了。代码就变成如下了</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MapT2F</span><span class="hljs-params">(ts []<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;, f <span class="hljs-keyword">func</span>(<span class="hljs-keyword">struct</span>&#123; Foo <span class="hljs-keyword">int</span> &#125;)</span> <span class="hljs-title">int</span>) []<span class="hljs-title">int</span></span> &#123;<br>  result := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ts))<br>  <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> ts &#123;<br>    result = <span class="hljs-built_in">append</span>(result, f(v))<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure><p>总结一下，在使用 make 初始化一个切片时，需要考虑是否指定切片的长度，并且长度是否会对接下来的操作造成影响。除此之外， append 的操作操作位置就是切片的长度所对应的位置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我是如何写程序的</title>
    <link href="/post/how-do-I-write-program..html"/>
    <url>/post/how-do-I-write-program..html</url>
    
    <content type="html"><![CDATA[<p>做为一名软件工程师，日常的工作就是去编写程序，写一段程序很简单，就比如 “hello world“。但是如果想要写好一段程序，就不是那么容易的事了，这篇文章主要是记录一下自己在编程时的一般流程。</p><h3 id="1-明确并且理解需求"><a href="#1-明确并且理解需求" class="headerlink" title="1. 明确并且理解需求"></a>1. 明确并且理解需求</h3><p>最近在读一本关于微服务架构的书，其中对需求有这样一个定义：</p><blockquote><p>需求是一个必须要解决的问题，以及围绕这个问题的特定上下文环境</p></blockquote><p>将每个开发任务当成需要解决的一道数学题。那么在解题的第一步就是要“读懂”题目， 也就是说理解题目在描述什么，并且明确问题的答案应该是什么。</p><p>所以在开始变编码之前一定要明确并且理解自己需要做什么，自己的产出会是什么。</p><p>如果将程序看作是对数据的一个映射，是一个函数，那么在确定好需要后，我们就可以得到如下的一个表达式</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">Output = F(Input)<br></code></pre></div></td></tr></table></figure><p>我们的任务就是完成函数 F, 在给定输入后，得到所需要的输出。</p><h3 id="2-分解编码步骤"><a href="#2-分解编码步骤" class="headerlink" title="2. 分解编码步骤"></a>2. 分解编码步骤</h3><blockquote><p>程序等于算法加上数据结构。</p></blockquote><p>在有了明确的问题之后，就需要思考如何去解决这个问题了。</p><p>在确认好需求之后，我就会在纸上列出已有的条件，然后思考如何完成 F。</p><p>首先， 我会定好输入输出的数据结构。</p><p>然后，我会开始画时序图或者是流程图，确认处理步骤，理清逻辑，划分模块。</p><p>最后，我把需要做的事拆分成一个个小的 task，写在便签上，产出 todo list。</p><h3 id="3-编写测试用例以及具体的程序"><a href="#3-编写测试用例以及具体的程序" class="headerlink" title="3. 编写测试用例以及具体的程序"></a>3. 编写测试用例以及具体的程序</h3><p>一个良好的程序是离不开单元测试的，单元测试保证了程序的正确性，也可以在之后的重构过程中起到至关重要的作用。</p><p>因此在划分好模块后，我会将需要的处理函数定义好。然后就是为这些函数编写各自的单元测试，通常我会编写三个测试，分别处理正常的数据，处于边界的数据，以及超出边界的程序。</p><p>在写完单元测试后就会跑一遍测试，这时不出意料所有的测试都应该是失败的，不过没关系，我的目标是让所有的测试通过。</p><p>接下来就是要去编写具体的程序，根据 task 将程序一步步的写完，每完成一个模块就跑一次测试，然后 commit。保证当前的程序是正常工作的。然后就是重复，code-test-commit 的步骤。</p><p>在完成所有的编码以及通过所有的测试之后，就将每个小 commit 合并成一个大的 commit。到目前为止基本的功能就完成了，但是这不代表我们的程序就没有问题的。这时候需要重新读一遍自己的程序，看看其中是否包含了 《重构》 中所说的坏味道的代码，如果有，那就进行重构，然后测试，提交。</p><p>在做完上面的所有工作时候，就可以提交自己的代码了。</p><p>以上就是我通常的编码过程了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go  函数式选项</title>
    <link href="/post/Golang-functional-option.html"/>
    <url>/post/Golang-functional-option.html</url>
    
    <content type="html"><![CDATA[<p>在实例化一个含有多个字段的结构体时，往往会封装一个工厂函数，类似于</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 用于示例，实际情况可能有更多的字端</span><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>  A <span class="hljs-keyword">string</span><br>  B <span class="hljs-keyword">int</span><br>  C <span class="hljs-keyword">int</span><br>  D <span class="hljs-keyword">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(a <span class="hljs-keyword">string</span>, b <span class="hljs-keyword">int</span>, c <span class="hljs-keyword">int</span>, d <span class="hljs-keyword">bool</span>)</span> *<span class="hljs-title">T</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;T&#123;<br>    A: a,<br>    B: c,<br>    D: d,<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但有些时候，我们只想对特定的字端进行赋值，而其他的字端则保持默认值。例如</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTWithA</span><span class="hljs-params">(a <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;T&#123;A: a&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTWithAB</span><span class="hljs-params">(a <span class="hljs-keyword">string</span>, b <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">T</span></span> &#123;<br>  <span class="hljs-keyword">return</span> &amp;T&#123;<br>    A:a,<br>    B:b,<br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>由于 Go 不支持函数重载，对于多个不同字端组合赋值初始时，往往需要多个工厂函数。这样太过于麻烦，因此需要一些辅助的手段来辅助处理。</p><p>对于这种情况，<strong>Rob Pike</strong> 提出了一种优雅的解决方式，函数式选项。区别于使用对象式选项传入一个 Option 对象的方式，函数式选项传入一个配置函数序列，其中的每个函数都会对所需要的对象进行一定的配置，最终构建出所需要的对象。</p><h2 id="使用函数式选项"><a href="#使用函数式选项" class="headerlink" title="使用函数式选项"></a>使用函数式选项</h2><p>首先定义选项 Option , 然后在使用闭包封装配置方法</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Option <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> <br><br><span class="hljs-comment">// Ta 将 T 的 A 设置为 a</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Ta</span><span class="hljs-params">(a <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">Option</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.A = a<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tb</span><span class="hljs-params">(b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Option</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.B = b<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tc</span><span class="hljs-params">(c <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Option</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.C = c<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Td</span><span class="hljs-params">(d <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">Option</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.D = d<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 同时设置 A，D 在某些情况下 A，D 存在相关性</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Tad</span><span class="hljs-params">(a <span class="hljs-keyword">string</span>, d <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">Option</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *T)</span></span> &#123;<br>    t.A = a<br>    t.D = d<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后修改一下NewT，使用 Option 来配置 T</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(ops ...Option)</span> *<span class="hljs-title">T</span></span> &#123;<br>t := &amp;T&#123;&#125;<br><span class="hljs-keyword">for</span> _, opt := <span class="hljs-keyword">range</span> ops &#123;<br>opt(t)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></div></td></tr></table></figure><p>最后来看一下使用的效果</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">// 只设置 A</span><br>  t := NewT(Ta(<span class="hljs-string">&quot;Ta&quot;</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t)  <span class="hljs-comment">// t is &amp;&#123;3 0 0 false&#125;</span><br>  <br>  <span class="hljs-comment">// 设置 B，C，D</span><br>  t2 := NewT(Tb(<span class="hljs-number">2</span>), Tc(<span class="hljs-number">3</span>), Td(<span class="hljs-literal">true</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t2) <span class="hljs-comment">// t is &amp;&#123; 2 3 true&#125;</span><br>  <br>  t3 := NewT(Tad(<span class="hljs-string">&quot;a and d&quot;</span>, <span class="hljs-literal">true</span>))<br>  fmt.Printf(<span class="hljs-string">&quot;t is %v \n&quot;</span>, t3) <span class="hljs-comment">// t is &amp;&#123;a and d 0 0 true&#125;</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>通过这种方式，我们就可以自由的配置需要的对象参数，并且省去了定义一堆长名字工厂函数的麻烦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Goland 远程开发</title>
    <link href="/post/goland-remote-deployment.html"/>
    <url>/post/goland-remote-deployment.html</url>
    
    <content type="html"><![CDATA[<p>最近准备写一个简单的容器管理工具，需要运行在 Linux 上。然而开发的机子是 MacBook，于是就想折腾一下自己的 goland，配置一下远程开发。</p><p>目标就是在本地编写的代码，一件部署到远程的服务器上并运行。</p><h3 id="配置远程的服务器"><a href="#配置远程的服务器" class="headerlink" title="配置远程的服务器"></a>配置远程的服务器</h3><p>在进行开发之前，首先需要把远程的服务器给配置好。远程服务器的版本为 Ubuntu 20.04 ，准备使用的协议是 SFTP，所以需要在 ubuntu 20.04 上配置一个服务器。配置过程如下：</p><ul><li><p>安装 ssh </p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo apt install openssh-server<br></code></pre></div></td></tr></table></figure></li><li><p>配置 ssh, 编辑 /etc/ssh/sshd_config，在最后加入</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">AllowGroups ssh-users sftp-users<br>Match Group sftp-users<br>ChrootDirectory /home<br>AllowTcpForwarding no<br>X11Forwarding no<br>ForceCommand internal-sftp<br></code></pre></div></td></tr></table></figure></li><li><p>重启 sshd</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo service sshd restart<br></code></pre></div></td></tr></table></figure></li><li><p>创建 sftp 用户组</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo addgroup sftp<br></code></pre></div></td></tr></table></figure></li><li><p>创建一个新的用户，加入到 sftp 组中, 设置密码</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo useradd -m sftpuser -g sftp<br>sudo passwd sftpuser<br></code></pre></div></td></tr></table></figure></li><li><p>最后赋予用户目录权限</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo chmod <span class="hljs-number">700</span> <span class="hljs-regexp">/home/</span>sftpuser/<br></code></pre></div></td></tr></table></figure></li><li><p>测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sftp sftpuser@127.0.0.1<br></code></pre></div></td></tr></table></figure></li></ul><p>配置完成没问题后，开始设置 Goland。</p><h3 id="配置-Goland"><a href="#配置-Goland" class="headerlink" title="配置 Goland"></a>配置 Goland</h3><p>Google 一下 Goland remote, 第一个结果就是 Jetbrains 家的文档。稳👍。<a href="https://www.jetbrains.com/help/go/creating-a-remote-server-configuration.html">地址在这🔗</a>。既然有官方文档，那就根据官方文档一步步的来。</p><ul><li><p>第一步，打开设置菜单：</p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">windows &amp;&amp; linux<br>File &gt; Settings &gt; <span class="hljs-keyword">Build, </span>Execution, Deployment &gt; Deployment <br><br>macOS<br>GoLand &gt; <span class="hljs-keyword">Preferences </span>&gt; <span class="hljs-keyword">Build, </span>Execution, Deployment &gt; Deployment<br></code></pre></div></td></tr></table></figure></li><li><p>接下来，点击 ‘Add’, 添加一个新的远程服务器，选择一个协议，因为远程服务器部署的是 SFTP，所以选择SFTP 然后输入名字，完成添加。</p></li><li><p> 新建一个 SSH configuration，输入地址、端口、用户名、密码，点击 Test connect. 确认没问题后，点击 OK</p></li><li><p>选择刚配置好的 ssh 并设置后目录以及 Web Server URL。</p></li><li><p>切换到 mapping， 将工作目录与远端的目录映射。</p></li></ul><p>至此就完成了远端部署的配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker 连接远程主机</title>
    <link href="/post/docker-remote-host.html"/>
    <url>/post/docker-remote-host.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在某些情况下，需要工作的电脑上 docker CLI 连接到另一台主机上的 docker 服务器。记下具体的配置过程。</p><h2 id="配置远程主机"><a href="#配置远程主机" class="headerlink" title="配置远程主机"></a>配置远程主机</h2><p>首先需要在远程主机上开启监听本地的端口， 修改 docker 的配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">vim /etc/docker/daemon.json<br></code></pre></div></td></tr></table></figure><p>修改，或增减 hosts 字段</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;hosts&quot;</span>: [<br><span class="hljs-string">&quot;unix:///var/run/docker.scok&quot;</span>,<br><span class="hljs-string">&quot;0.0.0.0:2376&quot;</span><br>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>修改完成后，重启 docker 服务</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></div></td></tr></table></figure><p>如果启动失败，可能是因为默认启动参数指定了 hosts，与新建的配置冲突了.</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">sudo vim /usr/lib/systemd/system/docker.servic<br></code></pre></div></td></tr></table></figure><p>将</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf"><span class="hljs-attribute">ExecStart</span>=<br></code></pre></div></td></tr></table></figure><p>后的 -H 参数去掉，再次重启。</p><p>确认 docker 在监听 2376 端口</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">netstat -ntlp | grep 2376<br></code></pre></div></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">tcp6</span>       <span class="hljs-number">0</span>      <span class="hljs-number">0</span> :::<span class="hljs-number">2376</span>                 :::*                    LISTEN      -<br></code></pre></div></td></tr></table></figure><h2 id="本地启动连接"><a href="#本地启动连接" class="headerlink" title="本地启动连接"></a>本地启动连接</h2><p>本地启动只需设置 <strong>DOCKER_HOST</strong> 变量即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DOCKET_HOST=tcp://host:2376<br>docekr ps<br></code></pre></div></td></tr></table></figure><p>即可看到远程主机上的 docker 容器了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>container</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DNS</title>
    <link href="/post/DNS.html"/>
    <url>/post/DNS.html</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Domain Name System(DNS)</a> 是一个用于计算机，服务以及其他资源连接到 Iternet 的分布式分层系统。DNS 是一个数据库，它保存了域名以及 IP 地址的映射。可以将域名转化成对应的 IP。</p><p>用户与互联网上的某台机器进行交互时，需要知道对方机器的 IP 地址，不论是 32 位还是点十分制的 IP 地址都不容易记忆，因此需要有一个容易记住的主机名称（域名），并且有一个对映的翻译系统（DNS），将主机名称翻译成对映的 IP 地址。</p><p>DNS 是一个联机分布式数据库，采用 C/S 架构。大多数的 DNS 解析都在本地进行，只有当本地没有相关记录时才会通过互联网进行通信，解析。</p><h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p>一次域名解析的过程可以概括为以下几个步骤：</p><ol><li>程序 A 需要解析 example.com, A 调用解析程序 Resolver</li><li>解析程序将域名放入 DNS 请求报文中，以 UDP 数据报方式发给本地域名服务器</li><li>本地域名服务器中有相关记录，将 IP 放在回答报文中返回，如果没有，进行 4</li><li>本地域名服务器向其他域名服务器发起请求，获取到 IP 地址，然后返回</li></ol><p>域名的解析方法有两种，</p><p>一是递归查询（recursive query），这种查询发生在本地域名服务器没有相关的域名记录时，他会成为域名查询的一个客户，向其他根域名服务器发起请求，而不是让主机进行下一次请求。所以，递归查询的结果要么是查询到对应的 IP，要么返回一个错误值，即指定的域名不存在。</p><p>二是迭代查询（iterative query），对根域名来说，当根域名服务器收到查询请求时，要么给出对应的 IP，要么返回本地域名服务器进行下一步查询的服务器的地址，之后本地域名服务器再进行后续的查询，通常返回的是一个顶级域名服务器。对于顶级域名服务器来说，要么返回 IP，要么返回进行下一步查询的权限域名服务器。</p><p>通过 dig 工具可以查看到具体的解析过程。</p><h2 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h2><p>域名的数据结构是一棵树，根节点没有名字，根域名的子节点为顶级域名，如 com，org，net等。</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams">   root<br> /   |   \<br><span class="hljs-function"><span class="hljs-title">com</span></span>  org net ... <br></code></pre></div></td></tr></table></figure><p>域名由 label 序列组成，每个 label 之间使用“ <strong>.</strong> ”隔开，如 <a href="http://www.example.com,级别最低的域名写在最左边,级别最高的域名写在最右边./">www.example.com，级别最低的域名写在最左边，级别最高的域名写在最右边。</a></p><p>域名由字母数字以及连字符组成，不区分大小写，EXAMPLE 与 example 是等效的。</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><ol><li><p>根域名服务器</p><p>最高层次的域名服务器，记录了所有顶级域名服务器的域名和IP地址，当本地域名服务器无法解析时，首先向根域名服务器发起查询请求。</p><p>根域名服务器只使用 13 个不同 IP 地址的域名，分别是 a.rootservers.net，b.rootservers.net … m.rootservers.net。</p></li><li><p>顶级域名服务器</p><p>负责管理在该顶级域名服务器注册的所有二级域名</p></li><li><p>权限域名服务器</p><p>负责一个区的域名服务器。</p></li><li><p>本地域名服务器</p><p>又称默认域名服务器，离用户近，一般不超过几个路由的距离。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cgo 内存释放</title>
    <link href="/post/cgo-memory-free.html"/>
    <url>/post/cgo-memory-free.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用 cgo，Go 可以与 C 语言代码进行交互，但是在使用过程中，如果使用的姿势不对，那么就有可能带来内存泄漏问题。</p><p>Go 自带 GC，一般情况下不会发生内存泄漏事件，自带的 GC 会收集不再使用的对象，并将其释放。但是在使用 cgo 时，某些函数会将 C 语言对象分配到 C 的堆上，在 Go 中初始化的 C 对象，是需要显示的调用 C.free() 去释放。官方文档也写明了这一点。在 cgo 的使用文档中，有关于 CString 函数的一段描述：</p><blockquote><p>The C string is allocated in the C heap using malloc.  It is the caller’s responsibility to arrange for it to be freed, such as by calling C.free (be sure to include stdlib.h  if C.free is needed).</p></blockquote><p>在将 Go 类型转化为 C 类型的函数中都有着相关的说明。</p><p>因此，<strong>分配在 C 堆上的内存需要调用 C.free() 去释放</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>以下的代码来自 cgo 官方博客，演示了如何使用 cgo 调用 c 语言代码</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// static void myprint(char* s) &#123;</span><br><span class="hljs-comment">//   printf(&quot;%s\n&quot;, s);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cs := C.CString(<span class="hljs-string">&quot;Hello from stdio&quot;</span>)<br>C.myprint(cs)<br>C.free(unsafe.Pointer(cs))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在代码的最后一行，通过调用 C.free() 手动释放了内存。</p><p>为了保证内存的正确释放，可以通过 defer 语句来释放内存。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">// #include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// static void myprint(char* s) &#123;</span><br><span class="hljs-comment">//   printf(&quot;myprint: %s\n&quot;, s);</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  cs := C.CString(<span class="hljs-string">&quot;Hello from stdio&quot;</span>)<br>  <span class="hljs-keyword">defer</span> C.free(unsafe.Pointer(cs))<br>C.myprint(cs)<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python map, filter, reduce  函数的注意事项</title>
    <link href="/post/undefined.html"/>
    <url>/post/undefined.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>注意：本文所说的 python 都是指 python3，python2 已不再被支持 :)</p></blockquote><p>map(), filter() 以及 reduce() 是 Python 中与函数式编程相关的三个函数，可以对可迭代序列做映射，过滤以及累积。熟练使用这三个函数可以提升编码速度，并且感受到函数式编程的一些思想。但是在使用过程中需要注意一些事项</p><p>TL;DR</p><ol><li>from functools import reduce.</li><li>返回对象，map, filter 返回可迭代对象，对象操作是惰性的</li></ol><span id="more"></span><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>map 与 filter 做为内置函数，可以直接使用，如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">1</span>, a))<br>c = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x : x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, a))<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># [2, 3, 4]</span><br><span class="hljs-comment"># [2]</span><br></code></pre></div></td></tr></table></figure><p>而 reduce() 函数的使用则需要从 <strong>functools</strong> 包中导入, 如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>reduce(<span class="hljs-keyword">lambda</span> x, y : x+y, a)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># 10</span><br></code></pre></div></td></tr></table></figure><p>同时，reduce() 中传入的函数的参数数量为两个。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>reduce 返回累积后的值，而 map 与 filter 返回的是可迭代的对象，分别为 map object 和 filter object。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">1</span>, a)<br><span class="hljs-built_in">print</span>(b)<br><br>c = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>, a)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># &lt;map object at 0xXXXXX&gt;</span><br><span class="hljs-comment"># &lt;filter object at 0xXXXXXXX&gt;</span><br></code></pre></div></td></tr></table></figure><p>map, filter 传入的函数，只有在返回的可迭代对象被消费时才会实际调用，即<strong>惰性求值</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;evaluation&quot;</span>)<br>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span><br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(test, a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not evaluation&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(b)) <span class="hljs-comment"># evaluation here because of list()</span><br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># not evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># evaluation</span><br><span class="hljs-comment"># [2, 3, 4]</span><br><br><br></code></pre></div></td></tr></table></figure><p>由于返回的是一个可迭代对象，因此所有的值只能迭代一次，再次尝试迭代，将会返回一个空集，如：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a)<br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;First iteration&quot;</span>) <br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Second iteration&quot;</span>)<br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># First iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># Second iteration</span><br></code></pre></div></td></tr></table></figure><p>因此，在如果需要多次使用返回的迭代对象，可以通过调用 list() 方法将其转化为一个 list 对象，之后使用生成的 list 对象即可。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><br>b = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x : x + <span class="hljs-number">1</span>, a))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;First iteration&quot;</span>) <br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Second iteration&quot;</span>)<br>[<span class="hljs-built_in">print</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b]<br><br><span class="hljs-comment"># output:</span><br><span class="hljs-comment"># First iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># Second iteration</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell Tips 💡</title>
    <link href="/post/shell-tips.html"/>
    <url>/post/shell-tips.html</url>
    
    <content type="html"><![CDATA[<p>一些关于 shell 的笔记</p><h2 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h2><p>在执行脚本时，确定当前的权限是否为 root</p><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$EUID</span>&quot;</span> -ne 0 ]<br>  <span class="hljs-keyword">then</span> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;not root&quot;</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><p>EUID, 用于系统决定用户对系统资源的访问权限，等于 0 时表示权限为 root。</p><h2 id="路径判断"><a href="#路径判断" class="headerlink" title="路径判断"></a>路径判断</h2><p>判断一个文件夹是否存在</p><p>代码：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ -d <span class="hljs-string">&quot;<span class="hljs-variable">$DIRECTORY</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># Control will enter here if $DIRECTORY exists.</span><br><span class="hljs-keyword">fi</span><br></code></pre></div></td></tr></table></figure><h2 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h2><p>字符串转为大写或小写</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">a=ABCDF123<br>a= $(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> | awk <span class="hljs-string">&#x27;&#123;print tolower($0)&#125;&#x27;</span>) <span class="hljs-comment"># abcdf123</span><br>a= $(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$a</span> | awk <span class="hljs-string">&#x27;&#123;print toupper($0)&#125;&#x27;</span>) <span class="hljs-comment"># ABCDF123</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词法分析</title>
    <link href="/post/lexical-analysis.html"/>
    <url>/post/lexical-analysis.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在之前的文章中，了解了什么是语言处理器，具体见<a href="https://zhangliangliang.cc/post/compiler-intro.html">这里</a>。接下来就是详细了解一下编译器的结构。</p><p>整体来看，一个编译器分为前端以及后端两个部分。</p><p>前端也就是分析部分，在这个阶段，编译器会将源程序分解成多个组成要素，然后在这些要素上加上语法结构，之后就会利用这个语法结构去创建程序的中间表示。</p><p>分析会对程序的语法，语义进行分析，如果存在不一致的情况，编译器就会返回相应的信息。与此同时，分析部分会搜集程序的一些信息，并且保存在<em>符号表</em>中。</p><p>在符号表中，源程序的标志符和它的声明或者使用信息绑定在一起，比如数据类型，作用域以及内存地址。</p><p>后端，也被称之为综合部分，后端接受到前端生成的中间形式以及符号表后，会根据这两者来构造目标程序。</p><p>首先来看，编译器的第一个步骤，词法分析。</p><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>词法分析是编译器处理过程中的第一步。词法分析器会读取并扫描源程序的字符流，然后将他们组织成有意义的词序的序列。对于每个词素，词法分析器会产生一个 token<em>（词法单元）</em>，形式如下：</p><p>​    &lt;token-name, attribute-value&gt;</p><p>token-name: 语法分析阶段所需要的抽象符号</p><p>attribute-name：指向符号表中保存这个 token 的记录的索引</p><p>假设有这样的一条语句</p><p>​    sum = a + f  * 6.0</p><p>词法分析器会从左到右进行扫描，并得到下列 token</p><p>​    &lt;id, 1&gt; &lt;=&gt; &lt;id, 2&gt; &lt;+&gt; &lt;id,3&gt; &lt;float, 3&gt;</p><ul><li>“sum” 会被映射为 &lt;id, 1&gt;，id 是 identifier <em>（标志符）</em> 的抽象表示， 1 表示 sum 在 符号表的中的条目。</li><li>“=” ：&lt;=&gt;, 等号不需要属性，因此省略第二个分量</li><li>其他的 token 映射规则和👆两个一样</li></ul><p>经过处理获得的 token 流会传给下一个步骤进行处理，即语法分析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 的一种并发模式：管道</title>
    <link href="/post/go-concurrency-pipeline.html"/>
    <url>/post/go-concurrency-pipeline.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go-管道模式"><a href="#Go-管道模式" class="headerlink" title="Go 管道模式"></a>Go 管道模式</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>这片文章是看完 Golang 官方博客后写下，记录下。原文在<a href="https://blog.golang.org/pipelines">这里</a></p><p>首先是 What is pipeline？官方博客上将管道看作是并发的程序的一种。一系列的 <em>stage</em> 通过 channel 串联起来。其中，每个 stage 都是一组执行相同任务的 goroutine。在每个 Stage 中，每个 goroutine 都会做三件事情：</p><ul><li>通过一个 channel 接收到要处理的上游数据。</li><li>对接收的数据做处理，通常是产生一个新的值</li><li>将产生的新数据传入另一个 channel 中，传递到下游。</li></ul><p>除了第一个和最后一个 Stage 以外，中间的 Stage 都会有几个传入和传出的数据通道，第一个只有传出，而最后一个只有传入。数据由第一个 stage 流入到最后一个 stage。</p><p>也就是说，在 Go 中的管道（pipeline）就像是一条生产线，一个零件从被生产到被消费，会经过几个不同的车间处理。第一个车间会生产最初的数据，而最后一个车间去消费这个数据。</p><span id="more"></span><p>为了更好的帮助理解，官方博客给出了例子。首先是最简单的一个例子：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// gen 根据传入的数字列表产生 channel， 并且将数字传入其中。</span><br><span class="hljs-comment">// 在完成传输后，gen 会关闭相应的 channel.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gen</span><span class="hljs-params">(nums ...<span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>            out &lt;- n<br>        &#125;<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// sq 从 上游的 channel 中接收数据，做平方后传入新的 channel 中。</span><br><span class="hljs-comment">// 与 gen 相同，sq 也会在完成任务后，将他产生的 channel 关闭。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sq</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> in &#123;<br>            out &lt;- n * n<br>        &#125;<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br><br><span class="hljs-comment">// main 函数负责设置 channel，并且消费 channel 中产生的数据。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> sq(sq(gen(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))) &#123;<br>        fmt.Println(n) <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 16</span><br><span class="hljs-comment">// 81</span><br></code></pre></div></td></tr></table></figure><h3 id="Fan-out-和-Fan-in"><a href="#Fan-out-和-Fan-in" class="headerlink" title="Fan-out 和 Fan-in"></a>Fan-out 和 Fan-in</h3><p>fan-out: 多个程序从一个 channel 中读取数据，直到 channel 关闭。就像是一个管理人，分发工作给多个工人的情况。</p><p>fan-in: 与 fan-out 相反，一个程序从多个 channel 中读取数据，直到所有的 channel 都关闭了。于此同时，会将处理后的数据送入一个新的 channel 中，并在完成工作后关闭它。 </p><p>例如，现在有一个 merge 函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>, cs ... &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><br>    <span class="hljs-comment">// Start an output goroutine for each input channel in cs.  output</span><br>    <span class="hljs-comment">// copies values from c to out until c is closed or it receives a value</span><br>    <span class="hljs-comment">// from done, then output calls wg.Done.</span><br>    output := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> c &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> out &lt;- n:<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>            &#125;<br>        &#125;<br>        wg.Done()<br>    &#125;<br><br>wg.Add(<span class="hljs-built_in">len</span>(cs))<br>    <span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> cs &#123;<br>        <span class="hljs-keyword">go</span> output(c)<br>    &#125;<br><br>    <span class="hljs-comment">// Start a goroutine to close out once all the output goroutines are</span><br>    <span class="hljs-comment">// done.  This must start after the wg.Add call.</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        wg.Wait()<br>        <span class="hljs-built_in">close</span>(out)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></div></td></tr></table></figure><p>原有的 gen 方法会被改造成下面的样子:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sq</span><span class="hljs-params">(done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">int</span></span> &#123;<br>    out := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(out)<br>        <span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> in &#123;<br>            <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> out &lt;- n * n:<br>            <span class="hljs-keyword">case</span> &lt;-done:<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">return</span> out<br>&#125;<br></code></pre></div></td></tr></table></figure><p>main 函数则变成:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Set up a done channel that&#x27;s shared by the whole pipeline,</span><br>    <span class="hljs-comment">// and close that channel when this pipeline exits, as a signal</span><br>    <span class="hljs-comment">// for all the goroutines we started to exit.</span><br>    done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><br>    in := gen(done, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><br>    <span class="hljs-comment">// Distribute the sq work across two goroutines that both read from in.</span><br>    c1 := sq(done, in)<br>    c2 := sq(done, in)<br><br>    <span class="hljs-comment">// Consume the first value from output.</span><br>    out := merge(done, c1, c2)<br>    fmt.Println(&lt;-out) <span class="hljs-comment">// 4 or 9</span><br><br>    <span class="hljs-comment">// done will be closed by the deferred call.</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过设置一个名为 done 的 channel, 下游的程序可以给上游的程序发送信号，通知他们停止生产数据，作为了一个反馈途径。</p><p>因此，如果想要构建一个 pipeline 系统, 有以下的要点：</p><div class="hljs code-wrapper"><pre><code class="hljs">- 当所有的操作完成后，stage 关闭通向外界的 channel。- stage 不断从流入 channel 中接收数据，直到这些 channel 关闭了或者是发送者解除阻塞状态。</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理学习</title>
    <link href="/post/compiler-intro.html"/>
    <url>/post/compiler-intro.html</url>
    
    <content type="html"><![CDATA[<h2 id="语言处理器"><a href="#语言处理器" class="headerlink" title="语言处理器"></a>语言处理器</h2><p>语言处理器就像是一个加工车间，某种程序设计语言编写的程序经过它的加工处理后，变成计算机可以执行的形式。语言处理器通常分为两种常见的形式，一是编译器，二是解释器。</p><p>编译器（Compiler）就像是一个翻译员，他将自己阅读到的程序，翻译成一个等价的，用另一种语言编写的程序。在这个过程中，他所阅读到的程序称之为 <em>源语言</em>，翻译成的语言称为 <em>目标语言</em>。整个过程如下：</p><blockquote><p>源程序 -&gt; [编译器] -&gt; 目标程序</p></blockquote><p>如果目标程序是一个可以执行的程序，那么它就可以被调用，来处理输入，产生输出。</p><blockquote><p> 输入 -&gt; [目标程序] -&gt; 输出</p></blockquote><p>除了翻译的职责外，编译器还承担着发现源程序中的错误的责任。</p><p>其次就是解释器（Interpreter），跟编译器的翻译相比，解释器就像是一个同声传译员，他在接受到源程序之后，就会立即翻译成目标语言，同时开始执行。</p><blockquote><p>输入 &amp; 源程序 -&gt; [解释器] -&gt; 输出</p></blockquote><p>编译器与解释器相比，由编译器产生的程序执行起来速度要比解释器快，以为在运行时不需要在依赖编译器或者额外的程序。但于此同时，由于解释器是逐行处理的，因此在错误诊断上的效果更加好。</p><h2 id="完整的处理过程"><a href="#完整的处理过程" class="headerlink" title="完整的处理过程"></a>完整的处理过程</h2><p>创建一个可执行的目标程序，不仅需要编译这一道处理，往往还需要其他的一些程序。</p><p>一个程序，根据设计，往往会被分成好几个模块，源代码散落在多个文件中，这时就需要一个程序来收集源代码文件，将他们聚合在一起。预处理器就是承担这个责任的。预处理器就像是一个装订工人，将各地的纸张收集起来，装订成册，有时候还需要根据指导手册修改纸上的内容（根据宏生成源程序的代码）。</p><p>在完成装订之后，这些“册子”就会作为输入，交给编译器去做翻译。在完成翻译后，通常会产生一本“汇编语言”的书籍。</p><p>然后，“书”会被交给汇编器（assembler）去做处理，在这之后的成品，就是可以重新定位的机器代码。</p><p>由于一个大程序经常会被分成多个部分编译，因此，可重新定位的机器代码有必要和其他的机器代码连接到一起。一个文件中，可能有着另一个文件中的地址。在这时，链接器（linker）就会站出来，根据各个文件的索引要求，把他们相互链接到一起。</p><p>最后，加载器（loader）就像运输工一样，负责把所有的执行目标文件送到到内存中，然后执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 使用过程中遇到的问题📝</title>
    <link href="/post/some-problems.html"/>
    <url>/post/some-problems.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在日常的开发过程中，主要使用的语言就是 Go。记录下使用过程中遇到的一些问题以及踩到的的坑。</p><h2 id="Json-序列化，Tag"><a href="#Json-序列化，Tag" class="headerlink" title="Json 序列化，Tag"></a>Json 序列化，Tag</h2><p>在 Go 中如果需要进行 Json 的序列化，常用到的方法有 <em>json.Marshal</em>。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span><br></code></pre></div></td></tr></table></figure><p>对需要序列化的结构体进行操作。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-keyword">string</span><br>    Body <span class="hljs-keyword">string</span><br>    Time <span class="hljs-keyword">int64</span><br>&#125;<br><br>m := Message&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1294706395881547000</span>&#125;<br>b, err := json.Marshal(m) <span class="hljs-comment">// 一切正常，err == nil。</span><br>b == []<span class="hljs-keyword">byte</span>(<span class="hljs-string">`&#123;&quot;Name&quot;:&quot;Alice&quot;,&quot;Body&quot;:&quot;Hello&quot;,&quot;Time&quot;:1294706395881547000&#125;`</span>) <br></code></pre></div></td></tr></table></figure><p>如果需要对生成 json 的字段进行指定，那么需要使用 tag，同时需要注意tag使用时的规范。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span> <span class="hljs-comment">// 正确使用 tag</span><br>Body <span class="hljs-keyword">string</span> <span class="hljs-string">`json:body`</span>   <span class="hljs-comment">// 没有加双引号</span><br>Time <span class="hljs-keyword">int64</span>                <span class="hljs-comment">// 不使用 tag</span><br>&#125;<br><br>m := Message&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1294706395881547000</span>&#125;<br>b, err := json.Marshal(m) <span class="hljs-comment">// 一切正常，err == nil。</span><br><br><span class="hljs-comment">// 只有 name 字段的字段名发生了改变</span><br>b == []<span class="hljs-keyword">byte</span>(<span class="hljs-string">`&#123;&quot;name&quot;:&quot;Alice&quot;,&quot;Body&quot;:&quot;Hello&quot;,&quot;Time&quot;:1294706395881547000&#125;`</span>) <br></code></pre></div></td></tr></table></figure><p>因此在使用过程中发现生成的字段名称不符合预期时，可以检查对应的 tag。</p><h2 id="Json-反序列化"><a href="#Json-反序列化" class="headerlink" title="Json 反序列化"></a>Json 反序列化</h2><p>与序列化时相同，在对需要反序列化的 byte slice 调用 <em>json.Unmarshal</em>.</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span><br></code></pre></div></td></tr></table></figure><p>使用时需要先声明一个变量用于存放反序列化后生成的对象。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m Message<br></code></pre></div></td></tr></table></figure><p>然后需要调用 json.Unmarshal，传入json 数据的 byte slice, 以及<strong>指向 m 的指针</strong>。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">err := json.Unmarshal(b, &amp;m)<br></code></pre></div></td></tr></table></figure><p>⚠️特别注意的是：如果在调用时没有传入指针，而是直接传入了 m， 那么将序列化失败，m 中将不包含任何信息。</p><p>在对某个 json 反序列化之后发现没有获取到任何的数据，debug 时可以注意，是否在编码时出现typo，没有使用指针，而是直接传入了 m。</p><p>同时在反序列化的过程中，会按照以下的以下的顺序查找对应的字段：</p><ul><li>是否是标签中声明的字段名</li><li>是否是结构体定义的字段名</li><li>是否是结构体定义的字段名的大小写变化后的名字，如”Foo”对应的”FOO”, “FoO”.</li></ul><p>如果都没有符合条件的选项，那么 Unmarshal 方法将会忽略这个字段，不对他进行处理。</p><h3 id="使用GOPROXY"><a href="#使用GOPROXY" class="headerlink" title="使用GOPROXY"></a>使用GOPROXY</h3><p>在国内使用 go get 命令获取依赖包时，由于🧱🧱的原因，导致无法安装某些依赖。比如 golang.org/x/net  包。为了解决这个问题，可以通过下载 github 上的源码，并将其放在 $GOPATH/src/golang.org/x 目录下，手动编译来解决。</p><p>除了手动下载编译外，还可以通过使用代理来进行下载。推荐使用 <a href="https://github.com/goproxy/goproxy.cn">goproxy</a>， goproxy 是七牛云搭建的代理服务，可以快速下载所需要的第三方依赖。</p><p>使用方法：</p><ul><li><p>Go 1.3 及以上版本（推荐）</p><p>执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ go env -w GOPROXY=https://goproxy.cn,direct<br></code></pre></div></td></tr></table></figure><p>其他版本可以通过设置环境变量 GOPROXY 来实现：</p></li><li><p> linux 以及 macOS </p></li></ul><p>  在 terminal 下执行</p>  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">export</span> GOPROXY=https://goproxy.cn<br></code></pre></div></td></tr></table></figure><p>  或者是</p>  <figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export GOPROXY=https://goproxy.cn&quot;</span> &gt;&gt; ~/.profile &amp;&amp; <span class="hljs-built_in">source</span> ~/.profile<br></code></pre></div></td></tr></table></figure><ul><li><p>Windows </p><p>打开 powershell， 执行：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">C:\&gt; <span class="hljs-variable">$env:GOPROXY</span> = <span class="hljs-string">&quot;https://goproxy.cn&quot;</span><br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>社会工程概要</title>
    <link href="/post/what-is-social-engineering.html"/>
    <url>/post/what-is-social-engineering.html</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>社会工程学不是一个神秘的工具，是一门科学，通过一些技巧来操纵他人采取特定行动。虽然这些行动不一定符合”目标人物”的最佳利益。使用社会工程的结果包括获取信息，取得访问权限或者让目标采取特定的行动。</p><p>在日常的生活中有两种最为常见的社会工程实例。一是骗子，骗子往往会采用社会工程的某些因素说服受害人，让其做出会给自身带来损失的行动。二是心理医生，心理医生会使用一系列精心设计的问题，帮助病人走出困境。</p><p>骗子和心理医生是社会工程的最真实形式，因为出发点的不同，使得他们在不同的目标身上产生了完全不同的结果。</p><p>社会工程就像烹饪，一种美食不会仅有一种成分，而是精心组合，调配以及添加多种配料而成。而社会工程人员使用社会工程框架中提到的各种技巧，组合搭配，使用少量的诱因，稍加操纵即可实现目的。</p><p>社会工程可以用于生活中的多个方面，存在着不同的形式，既可以是恶意的，也可以是善意的，既可以产生激励作用，也可以具有毁灭性。</p><h2 id="使用社会工程的人员"><a href="#使用社会工程的人员" class="headerlink" title="使用社会工程的人员"></a>使用社会工程的人员</h2><ul><li>黑客：由于软件攻击和网络入侵的难度提升，通过使用社会工程来进行攻击</li><li>渗透测试者：与黑客不同，使用社会工程手段来确保客户的安全</li><li>间谍：社会工程专家，使用社会工程来获取信任，窃取情报</li><li>身份盗用者：在当事人不知情的情况下，盗用身份信息</li><li>骗子：利用贪婪，恐惧心理，使用社会工程的技巧进行诈骗</li><li>高端猎头：既考虑求职者的需求也审视雇主的想法</li><li>销售人员：利用技巧发现人们的需求</li><li>政府：利用社会认同，权威性和稀缺资源来确保目标的受控性</li><li>医生，心理医生和律师：使用谈话技巧，社会工程的心理原则，操纵客户采取期望的行动</li></ul><p>学习社会工程不仅能增强自身技能，而且可以提高警觉，避免被操控。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 结构体</title>
    <link href="/post/go-struct.html"/>
    <url>/post/go-struct.html</url>
    
    <content type="html"><![CDATA[<h2 id="结构体介绍"><a href="#结构体介绍" class="headerlink" title="结构体介绍"></a>结构体介绍</h2><p><strong>结构体</strong>是一种数据结构，通过实现复杂的结构来表示现实世界中的实体。<strong>结构体</strong>同时也是一些元素的集合，这些元素称为<strong>结构体</strong>的成员（又称字段），且这些成员可以为不同的类型，成员一般用名字访问。</p><p>结构体的声明一般是以 <strong>type</strong> 开始，并依次包含类型名称、关键字 <strong>struct</strong> 以及由花括号包裹的成员列表。</p><p>声明语句如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Student 是一个表示学生的结构体</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>  Id   <span class="hljs-keyword">int</span><br>  Name <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中，每个字段的声明都需要<strong>独占一行</strong>，且名字要<strong>唯一</strong>。如果字段在代码中从来也不会被用到，那么可以命名它为”_”。</p><span id="more"></span><h2 id="带有标签的结构体"><a href="#带有标签的结构体" class="headerlink" title="带有标签的结构体"></a>带有标签的结构体</h2><p>除了成员除了名称以及类型之外，还可以选择一个标签。标签是一个附属于字段的字符串，只有 <strong>reflect</strong> 可以操作它。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>  Id   <span class="hljs-keyword">int</span> <span class="hljs-string">`json:&quot;Id&quot;`</span><br>  Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;Name&quot;`</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用 <strong>reflect</strong> 来获取其中的值：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;Id&quot;`</span> <span class="hljs-comment">// 表明 Json 序列化时的名称。</span><br>Name <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;Name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>std := Student&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>&#125;<br><br>t := reflect.TypeOf(std)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>ixField := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, ixField.Tag)<br>&#125;<br><span class="hljs-comment">// 输出</span><br><span class="hljs-comment">// json:&quot;Id&quot;</span><br>  <span class="hljs-comment">// json:&quot;Name</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h2><ol><li>使用 new 方法实例化一个结构体, 将会对该变量赋于一块内存，并返回指向内存的指针。</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>(Student)<br>fmt.Println(s)<br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// &amp;&#123;0 &#125;</span><br></code></pre></div></td></tr></table></figure><p>使用 new(Type) 等价于 **&amp;Type{}**，因为后者在底层调用了 new 方法。</p><p>除此之外，使用 var t T 也会给 t 分配内存，并零值化内存，但此时 t 的类型是 <strong>T</strong>，而不是指向它的一个指针。</p><ol start="2"><li>使用工厂方法。</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewStudent</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Student</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Student&#123;<br>Id:   id,<br>Name: name,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := NewStudent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Apple&quot;</span>)<br>size := unsafe.Sizeof(s) <span class="hljs-comment">// 了解 s 所占用的内存</span><br>fmt.Println(s)<br>fmt.Println(size)<br>&#125;<br><br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// &amp;&#123;1 Apple&#125;</span><br><span class="hljs-comment">// 8</span><br></code></pre></div></td></tr></table></figure><p>如果想要强制使用工厂方法，可以将<strong>类型设置为私有的</strong>，那么在其他包调用时只能使用工厂方法，而不能通过 new 方法来实例化。</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><p>与数组类型相同，结构体类型是<strong>值类型</strong>。结构体类型的零值并不是 nil。如之前的 Student 的零值就是 Student{0  }。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>郝林. Go 并发编程实践（第二版）. 人民邮电出版社<sub>（中文）</sub>.</li><li><a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.1.md">the-way-to-go_ZH_CN</a>. “结构体的定义”.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 接口类型</title>
    <link href="/post/go-interface.html"/>
    <url>/post/go-interface.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>Go 语言中的接口用于定义一组行为。其中，每个行为都是一个由一个方法进行声明的。</p><p>在声明一个接口时，只需要声明方法的名称，方法的参数列表以及结果列表即可。如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">interface</span> &#123;<br>  Listen(<span class="hljs-keyword">string</span>)<br>  Say() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Person 接口就是定义了一组与 “Person” 相关的行为。</p><p>接口类型是无法实例化的，这意味着无法使用 new 或 make 函数来创建接口类型的值。同样的，也不可以使用一个字面量来表示某个接口的值。</p><span id="more"></span><h2 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h2><p>如果一个数据类型 <strong>T</strong> 的方法集合中包含了接口 <strong>I</strong> 声明的所有方法，那么它就是 <strong>I</strong> 的实现类型。即  “Duck Typing”。</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> T <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Listen</span><span class="hljs-params">(word <span class="hljs-keyword">string</span>)</span></span> &#123;<br>  <span class="hljs-comment">// .....</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;T&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>T 的所有指针方法都包含了 Person 所声明的方法，因此 *T 类型就是 Person 的实现类型。⚠️注意的是，T 类型并不是， *T 类型才是。</p><p>在 Go 中，数据类型之间并<strong>不存在继承关系</strong>，只有组合关系。这意味着，可以在一个接口类型的声明中嵌入任意数量的其他接口类型。让一组行为包含其他的行为组。例如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TPerson <span class="hljs-keyword">interface</span> &#123;<br>  Person<br>  Eat(<span class="hljs-keyword">string</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="动态类型与静态类型"><a href="#动态类型与静态类型" class="headerlink" title="动态类型与静态类型"></a>动态类型与静态类型</h2><p>有如下两个变量：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> t T = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-keyword">var</span> p Person = &amp;t<br></code></pre></div></td></tr></table></figure><p>被赋予接口类型变量的值称为<strong>动态值</strong>， &amp;t 就是 p 的动态值；</p><p>动态值的类型就是<strong>动态类型</strong>，p 的动态类型是 *T；</p><p>接口变量本身的类型就是 <strong>静态类型</strong>，p 的静态类型就是 Person，并且一直都是。</p><p>此外，如果有另外一个类型 *T2 也实现了 Person 接口，并且 *T2 类型的值被赋予了 p， 那么 p 的动态类型就变为了 *T2.</p><p>在接口类型的变量被赋值之前，它的动态类型并不存在。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 优化表空间</title>
    <link href="/post/mysql-optimize-table.html"/>
    <url>/post/mysql-optimize-table.html</url>
    
    <content type="html"><![CDATA[<p>在使用 MySQL 的过程中，可能会出现如下的情况：</p><p>使用 delete 语句删除大部分数据之后，表文件的大小却并没有发生变化。导致这种情况出现的原因有多种。</p><h2 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h2><p>首先是 <strong>innodb_file_per_table</strong> 这个参数的设置。这个参数的作用是控制表文件的存放位置。</p><ul><li><strong>OFF</strong>：表数据放在系统表共享空间之中，即数据字典的存放处</li><li><strong>ON</strong>：每张表的数据单独存放在 <strong>.ibd</strong> 的文件中</li></ul><p>在设置为开启之后，使用 drop table 命令就会删除掉表的数据文件，从而回收空间。</p><span id="more"></span><h2 id="MySQL-数据中的空洞"><a href="#MySQL-数据中的空洞" class="headerlink" title="MySQL 数据中的空洞"></a>MySQL 数据中的空洞</h2><p>其次是表记录删除过程所导致的”<strong>空洞</strong>“。在对表的记录进行删除时，delete 命令会将记录的位置或者数据页的状态标记为<strong>可复用</strong>，而磁盘文件的大小并不会产生变动。</p><p>标记为可复用的位置如果没有新的数据填入，那么空洞就会一直存在，这将导致即使是数据被删除了，但是整体文件的大小却没有变化。</p><p>除此之外，由于插入数据的随机，导致数据页分裂也会导致空洞的产生。</p><p>为了消除文件中的空洞，优化整体的空间，需要使用到重建命令对表重建。命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">ALERT TABLE t_name ENGINE = InnoDB;<br></code></pre></div></td></tr></table></figure><h2 id="表的重建过程"><a href="#表的重建过程" class="headerlink" title="表的重建过程"></a>表的重建过程</h2><p>MySQL 对表的重建是 online 的， 过程如下：</p><ol><li>首先建立一个临时文件， tmp；</li><li>将表 T 中的所有数据存储到 tmp 中；</li><li>记录替换过程中表 T 的所有操作，写入 raw  log 中；</li><li>根据 raw log 中的记录，操作 tmp；</li><li>使用 tmp 替换 T；</li></ol><p>在重建表之后才能收缩表空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语法概览 Part 2</title>
    <link href="/post/Go-grammar-overview-2.html"/>
    <url>/post/Go-grammar-overview-2.html</url>
    
    <content type="html"><![CDATA[<p>这是 Go 学习笔记的第二篇，继续对 Go 的语法进行一个概览，你可以在<a href="https://zhangliangliang.cc/post/Go-grammar-overview-1.html">这里</a>看到第一篇。</p><p>本篇将聚焦于 Go 语言的数组，切片，字典以及函数。</p><h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1 数组"></a>1 数组</h2><p>Array（数组）是一个由数个相同类型的元素构成的序列。例如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stds [<span class="hljs-number">4</span>]<span class="hljs-keyword">string</span> = [<span class="hljs-number">4</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><p>数组的长度是数组类型的一部分。拥有相同元素类型的数组，如果长度不同，那么就不是相同的数组。数组的长度一经声明，就不可以再改变了。</p><p>声明语句的右半部分也可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">[...]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125; <span class="hljs-comment">// Go 编译器将计算元素的数量，并获得长度</span><br></code></pre></div></td></tr></table></figure><span id="more"></span><h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2 切片"></a>2 切片</h2><p>slice（切片）对数组的一种包装形式，被它包装的数组被叫做切片的底层数组。它表述了底层数组中的一个连续片段。</p><p>声明形式如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> stds = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><p>切片的类型不包含长度信息，因此拥有相同元素类型的切片，他们的类型就是相同的。</p><p>切片的<strong>长度可变</strong>，零值为 nil，当处于零值时，长度和容量都是0。其中，切片的容量是指在没有更换底层数组时长度的最大值。</p><p>切片的初始化可以通过内建函数  <strong>make</strong> 进行，通过使用 make 能以很短的代码初始化一个长度很大的切片。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">stds := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">100</span>)<br></code></pre></div></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3 字典"></a>3 字典</h2><p>map（字典）是 hash table 的一个实现。map 是 key-value 形式元素对的一个无序集合。map 中的每个索引都是独一无二的。</p><p>map 的声明如下所示：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mStds = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><p>map 的零值为 nil，零值的长度是 0。map 的长度表明了其中所含有的 key-value 对的数量。</p><p>map 数据的<strong>添加与修改</strong> ：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">mStds[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-string">&quot;1&quot;</span><br></code></pre></div></td></tr></table></figure><p><strong>删除</strong>：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(mStds, <span class="hljs-string">&quot;a&quot;</span>) <span class="hljs-comment">// 无论是否存在 “a“, 都将会执行完毕。</span><br></code></pre></div></td></tr></table></figure><p><strong>查询</strong>：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">value, has := mStds[<span class="hljs-string">&quot;a&quot;</span>]<br></code></pre></div></td></tr></table></figure><h2 id="4-函数"><a href="#4-函数" class="headerlink" title="4 函数"></a>4 函数</h2><p>函数在 Go 中是作为一等公民形式存在的，可以将函数作为一个值来传递和使用。</p><p>一个函数的声明通常包括关键字 func， 函数名，由圆括号包围的参数列表和结果列表，以及花括号包围的函数体。如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">A</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span><span class="hljs-params">(res <span class="hljs-keyword">int</span>, err error)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>为了辨别不同的函数，需要使用<strong>函数签名</strong>，函数签名是函数参数列表以及结果列表的统称。函数签名不包括参数和结果的名称。</p><p>如果两个函数参数列表和结果列表的顺序以及类型相同，那么，这两个函数实现了同一个函数类型。</p><p>函数也可以用来实现<strong>闭包</strong>。所谓闭包，就是将某个函数类型作为闭包函数的一个参数，在调用时根据需求传动态传入函数，产生不同的行为。闭包函数在定义时并不会知道某个函数类型的具体实现，只有在调用时才会知道。如：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> operate <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br><span class="hljs-keyword">type</span> calculateFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">genCalculater</span><span class="hljs-params">(op operate)</span> <span class="hljs-title">calculateFunc</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> op == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;invalid operation&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> op(x, y), <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x, y := <span class="hljs-number">5</span>, <span class="hljs-number">7</span><br>op := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x * y<br>&#125;<br>mult := genCalculater(op) <span class="hljs-comment">// 生成乘法运算函数</span><br>result, err := mult(x, y)<br>fmt.Printf(<span class="hljs-string">&quot;result: %d (error: %v)\n&quot;</span>, result, err)<br><br>op2 := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br>add := genCalculater(op2) <span class="hljs-comment">// 生成加法运算函数</span><br>result, err = add(x, y)<br>fmt.Printf(<span class="hljs-string">&quot;result: %d (error: %v)\n&quot;</span>, result, err)<br><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语法概览 Part 1</title>
    <link href="/post/Go-grammar-overview-1.html"/>
    <url>/post/Go-grammar-overview-1.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章是对 Go 语言的基本语法做的一个笔记。计划用三篇文章来记录，这篇主要记录 Go 的词法元素。</p><h2 id="词法元素"><a href="#词法元素" class="headerlink" title="词法元素"></a>词法元素</h2><p>Go 语言的词法元素，也叫做语言符号，分为 5 类，如下所示：</p><ol><li>identifier：标识符</li><li>keyword：关键字</li><li>literal：字面量</li><li>delimiter：分隔符</li><li>operator：操作符</li></ol><span id="more"></span><h3 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h3><p>Go 语言中的标识符可以大致分为两类，一类用以表示<strong>程序实体</strong>，作为后者的名称而存在。其可以是 Unicode 字符集中任意能表示自然语言文字的字符、数字以及下划线（_）。</p><p>Go 中的变量、常量、函数和类型声明统称为程序实体。</p><p>在 Go 中标识符的首字母的大小写控制着对应程序实体的访问权限。</p><ul><li>首字母大写：对应的程序实体就可以被本代码包之外的代码访问到，既公开的。</li><li>首字母小写：对应的程序实体只能被本代码包的代码访问，既包级私有。</li></ul><p>空标识符 “_“，用于变量声明或代码包的导入语句中。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 初始化某个代码包，但不在当前文件中使用它的任何程序实体。</span><br><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// 如果 x 声明后没有使用，编译器会报错。</span><br><span class="hljs-comment">// 使用空标识符可以绕过编译器检查。</span><br><span class="hljs-comment">// 在初始化后操作的对象就会被弃之不用。</span><br>_ = x<br></code></pre></div></td></tr></table></figure><p>另一类是<strong>预定义标识符</strong>，在 Go 语言的源码中被声明。分为以下几种：</p><ul><li>所有基本类型的名字</li><li>接口类型 error</li><li>常量 true，false 以及 itoa</li><li>所有内建函数的名字，append、cap、close、complete、copy、delete、imag、len、make、new、panic、print、prinln、real、recover。</li></ul><h3 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h3><p>Go 的关键字可以分为三类：</p><ul><li>程序声明：import 和 package</li><li>程序实体声明：chan、const、func、interface、map、struct、type、var</li><li>程序流程控制：go、select、break、case、continue、default、defer、else、fallthrough、for、goto、if、range、return、switch</li></ul><p>使用 type 关键字可以声明一个自定义类型</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> customString <span class="hljs-keyword">string</span><br></code></pre></div></td></tr></table></figure><p>声明的自定义类型是被声明类型的一个别名类型。例如 rune 与 int32。两者之间的转换不会产生新值。</p><h3 id="oprator"><a href="#oprator" class="headerlink" title="oprator"></a>oprator</h3><p>Go 语言的操作符优先级，从高到低排列：</p><ul><li>*<strong><strong>、</strong>/<strong>、</strong>%<strong>、</strong>&lt;&lt; 、&gt;&gt;、 &amp;、 &amp;^</strong></li><li><strong>+ 、- 、|、 ^</strong></li><li><strong>==、！=、&lt;、&lt;=、&gt;、&gt;=</strong></li><li>&amp;&amp;</li><li>||</li></ul><h3 id="literal"><a href="#literal" class="headerlink" title="literal"></a>literal</h3><p>字面量：值的一种标记法。有三类：</p><ul><li><p>表示基础数据类型值的字面量。如，表示浮点数类型值的 <strong>12E-3</strong></p></li><li><p>构造自定义复合数据的类型字面量。如，</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>    Name <span class="hljs-keyword">string</span><br>    Age <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>表示复合数据类型的值的字面量。如，</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">Person&#123;Name: <span class="hljs-string">&quot;name&quot;</span>, Age: <span class="hljs-number">12</span>&#125;<br></code></pre></div></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给字符串来个索引</title>
    <link href="/post/index-on-string.html"/>
    <url>/post/index-on-string.html</url>
    
    <content type="html"><![CDATA[<p>在了解到索引的重要性，以及如何建立一个高效的索引后，就可以面对一些实际的需求进行操作，如何对常见的邮箱字段建立索引。</p><p>邮箱常作为登录时的字段，在用户登录的时候，往往需要对邮箱所在的表进行检索。如果没有针对邮箱字段建立索引的话，那么就只能进行全表扫描了，这种情况下，效率是十分的低的。</p><p>同时，邮箱作为一个字符串，可以利用 MySQL 的前缀原则，可以将邮箱的一部分定义为索引。</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> n 是指定的字符串长度，如果不写，则默认为全部长度。<br><span class="hljs-operator">&gt;</span> alert <span class="hljs-keyword">table</span> t_name <span class="hljs-keyword">add</span> index index_name(email(n));<br></code></pre></div></td></tr></table></figure><span id="more"></span><h2 id="使用字符串前缀索引的优劣"><a href="#使用字符串前缀索引的优劣" class="headerlink" title="使用字符串前缀索引的优劣"></a>使用字符串前缀索引的优劣</h2><p>使用了前缀索引之后，可以<strong>节省空间</strong>，但是如果长度选取不够合理的时候，会<strong>增加读取数据的次数</strong>。</p><p>在前缀的长度选取不合理的情况下，M 个记录的前 N 个字段是完全相同的，这时，数据库需要在索引树上进行 M 次判断后才能选取到正确的结果集。</p><p>因此在对字符串建立前缀索引时，选取的前 N 个字符需要<strong>具有区分度</strong>。这样的话才能既节省空间，也不会让查询成本上升。</p><h2 id="前缀索引的其他使用方式"><a href="#前缀索引的其他使用方式" class="headerlink" title="前缀索引的其他使用方式"></a>前缀索引的其他使用方式</h2><p>如果字符串具有区分度的前 N 个字符的 N 值太大，可以利用别的方法建立索引。</p><p>一是<strong>倒序存储</strong>，将需要建立索引的字符串进行倒序后存储，从倒序的字符串中选取具有区分度的前 N 个字符建立索引，然后在查询的时候使用 <strong>reverse</strong> 函数。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> field_name <span class="hljs-keyword">from</span> t_name <span class="hljs-keyword">where</span> index_str <span class="hljs-operator">=</span> reverse(<span class="hljs-string">&#x27;input_string&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>二是利用 <strong>hash</strong> ，在表中新建一个字段，存储字符串的校验码。在存储时调用 hash 函数生成校验码存入数据库中。这种方法会增加额外的存储消耗。</p><p>这两个方法生成的索引都<strong>无法支持范围查询</strong>。</p><p>最后，使用了前缀索引后会影响到覆盖索引，无法再获得覆盖索引所带来的优化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你好，思维导图</title>
    <link href="/post/hello-mind-map.html"/>
    <url>/post/hello-mind-map.html</url>
    
    <content type="html"><![CDATA[<p>今天在浏览推荐 Mac 使用的软件清单时，又看到了一个熟悉的身影——<a href="https://www.xmind.cn/">Xmind</a>，一款用于制作<a href="https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E5%9B%BE">思维导图</a>的工具。多次的交汇，最终激起了我使用他的欲望，同时也想看看使用思维导图能否帮助自己思考。</p><p>在 Google 上搜索思维导图，出现了一大批相关的结果，从介绍思维导图，到教你使用思维导图，再到推荐各种思维导图工具，比如我准备尝试的这款：Xmind。</p><p>面对着众多赞扬，我也按耐不住自己的好奇心，想去看看思维导图究竟是有着怎样的魅力。看看它是不是真的如它的推崇者所说的那样具有神奇的魔力，让自己的效率获得提升。</p><p>因此，我选中了推荐人数领先的 Xmind，从今天开始，我会使用它来绘制思维导图，帮助自己去梳理思绪，记录自己的一些笔记。</p><p>最后，思维导图，请多多关照🙇。</p>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>思维导图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记-索引篇-第二话</title>
    <link href="/post/MySQL-note-index-part2.html"/>
    <url>/post/MySQL-note-index-part2.html</url>
    
    <content type="html"><![CDATA[<p>这是 MySQL 笔记索引部分的第二篇，聚焦于如何更好的使用索引。<a href="/post/MySQL-note-index-part1">第一篇</a>聚焦于介绍什么是索引，索引的一些数据模型，以及 MySQL 中与索引相关的操作语句。</p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>MySQL 在利用索引进行查询时，可能会发生<strong>回表</strong>行为，不可避免的会影响到查询的效率。为了进一步的提高查询效率，可以利用一些手段避免回表。</p><span id="more"></span><p>之所以会发生回表，是因为二级索引树上没有存储需要查询的字段，只能查询到该记录所在行的主键，必须回到主索引树去查询相应的字段。</p><p>如果在二级索引上可以直接获得相应的值，那么就不会产生回表了，例如：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/*ID 是主键，k 是索引*/</span><br><span class="hljs-keyword">SELECT</span> ID <span class="hljs-keyword">FROM</span> table_test <span class="hljs-keyword">WHERE</span> k<span class="hljs-operator">=</span><span class="hljs-string">&#x27;key&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p>这被称为 <strong>覆盖索引</strong>，因为索引 k “覆盖” 了查询需求，利用 k 可以直接获得想要的结果。</p><p>可以看到，使用覆盖索引之后，整个查询过程中对树的搜索次数被明显减少了，由此可以带来显著的性能提升。</p><h3 id="通过联合索引完成覆盖索引"><a href="#通过联合索引完成覆盖索引" class="headerlink" title="通过联合索引完成覆盖索引"></a>通过联合索引完成覆盖索引</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>当存在一个高频的需求，需要根据某个索引查找另一个字段数据，在这种情况下，就可以建立<strong>联合索引</strong>，在这个请求上应用到覆盖索引，减少了语句的运行时间。</p><p>例如，在如下的一张表：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `student` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `cid` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `name_cid_INX` (`name`,`cid`),<br>)<br></code></pre></div></td></tr></table></figure><p>根据 name 查询 cid 的时候，就不需要经历回表了，可以直接通过所在的索引树获取到结果。</p><p>建立这样的索引在提升查询效率的同时，也会因为冗余问题而付出代价，在具体应用时需要权衡一番。</p><h4 id="使用最左前缀原则"><a href="#使用最左前缀原则" class="headerlink" title="使用最左前缀原则"></a>使用最左前缀原则</h4><p>在 B+ 树中，索引项会根据索引的最左前缀来进行排序，可以是联合索引的定义中出现最左 M 个字段，也可以是字符串索引的最左 N 的字符。</p><p>只要符合索引的最左前缀，就可以利用该索引来进行搜索了。</p><p>例如，上一段中的 (‘name’, ‘id’) 索引，其索引项的排序就会如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">|（‘Appl<span class="hljs-string">e&#x27;,&#x27;</span><span class="hljs-number">12</span><span class="hljs-string">&#x27;）| (&#x27;</span>Banana<span class="hljs-string">&#x27;, 13)  | (&#x27;</span>Banana<span class="hljs-string">&#x27;, 13)  | (&#x27;</span>Banana<span class="hljs-string">&#x27;, 14)|</span><br><span class="hljs-string">----------------------------------------------------------------------</span><br><span class="hljs-string">|    ID_1       |       ID_2      |    ID_3         |    ID_5        |</span><br><span class="hljs-string"></span><br><span class="hljs-string">-----&gt;</span><br></code></pre></div></td></tr></table></figure><p>查找 ‘Banana’ 时，就会定位到 ID_2, 然后向后查找；同样当查找 ‘Ba%’ 时，也可以利用该索引定位到 ID_2， 然后向后查找。</p><p>因此，当需要建立联合索引时，如果可以通过索引的位置顺序调整，来减少一个索引，那么就可以采用这种顺序来建立联合索引。</p><p>但是，当存在 name, cid 的联合查询，以及分别基于 name 和 cid 的单独查询时，需要维护两个索引，分别是 （’name’, ‘cid’) 以及 （’cid’)。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当建立索引时，需要考虑到会出现的高频需求，各个需求之间能否合并建立联合索引来减少索引项。综合考虑到各种情况后，建立最合适的索引。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL笔记——索引篇第一话</title>
    <link href="/post/MySQL-note-index-part1.html"/>
    <url>/post/MySQL-note-index-part1.html</url>
    
    <content type="html"><![CDATA[<p>最近在学习 MySQL 的内容，重头梳理了一下相关的知识点，在这里记录一下。</p><p>这里主要讲一下 MySQL 索引方面的知识。</p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是一张表，它保存了主键与索引字段，指向了实体表的记录。</p><span id="more"></span><p>如果说记载了各项记录的实体表是一本书的话，那么索引就是这本书的目录，利用它可以对记录进行快速的查找，提高查询效率。</p><p>索引分为两种，一种是<strong>单列索引</strong>，另一种是<strong>组合索引</strong>。</p><p>单列索引，顾名思义，就是每个索引只包含了一列，一张表可以有多个单列索引，而组合索引则是一个索引包含多个列。</p><h2 id="索引的实现"><a href="#索引的实现" class="headerlink" title="索引的实现"></a>索引的实现</h2><p>了解了什么是索引之后，就会想着怎么去利用数据结构去实现索引。</p><p>首先，索引与实体表记录之间存在着一一对应的映射关系，最容易想到的能够反映映射关系的数据结构就是<strong>哈希表</strong>。</p><p>哈希表是 key-value 类型存储数据的数据结构，只需要输入待查找的 key，就可以获得对应的 value 值。</p><p>哈希表的优点在于哈希表查找的时间复杂度是 O(1)，查找效率非常的高。但是哈希表也存在着缺点，那就是哈希表的存储的数据是无序的，如果需要进行区间查询，效率会非常的低。</p><p>其次，可以做为存储结构的是有序数组，有序数组的优点是查找效率高，同时它也支持区间查找，但是有序数组的插入十分低效，每一次插入都需要移动插入位置后的所有数据。适用于存储不会再修改的的数据，即静态存储引擎。</p><p>最后则是 N 叉树，利用 N 叉树既能保证搜索的效率，以及区间查找，又能保证插入修改的效率。因此在 InnoDB 引擎中就是使用 <strong>B+ 树</strong>来存储数据的。</p><p>根据 B+ 树叶子节点的不同，将索引分为两种：</p><ul><li>主键索引（聚簇索引 clustered index）：存储的是整行数据。</li><li>二级索引（secondary index）：存储的是主键的值。</li></ul><p>使用主键索引查找时，直接查找主键索引所在的 B+ 树；而利用二级索引进行查找时，会先在二级索引所在的 B+ 树上查找到对应的主键值，然后再去根据获取到的主键值去主键索引所在的 B+ 树上进行查找，这个过程被称之为回表。</p><p>基于二级索引的查询，会多遍历一次 B+ 树，因此尽量多使用主键查询。</p><h2 id="索引的操作语句"><a href="#索引的操作语句" class="headerlink" title="索引的操作语句"></a>索引的操作语句</h2><h3 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>创建最基本的索引，没有任何的限制条件：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX indexName <span class="hljs-keyword">ON</span> tableName(columnName(length));<br></code></pre></div></td></tr></table></figure><p><em>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length.</em></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX indexName <span class="hljs-keyword">ON</span> tableName(columnName(length));<br></code></pre></div></td></tr></table></figure><h3 id="2-修改表结构方式添加"><a href="#2-修改表结构方式添加" class="headerlink" title="2. 修改表结构方式添加"></a>2. 修改表结构方式添加</h3><h4 id="普通索引-1"><a href="#普通索引-1" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">ADD</span> INDEX indexName(columnName)<br></code></pre></div></td></tr></table></figure><h4 id="唯一索引-1"><a href="#唯一索引-1" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">table</span> tableName <span class="hljs-keyword">ADD</span> INDEX indexName(columnName)<br></code></pre></div></td></tr></table></figure><h3 id="3-创建表的时候指定"><a href="#3-创建表的时候指定" class="headerlink" title="3. 创建表的时候指定"></a>3. 创建表的时候指定</h3><h4 id="普通索引-2"><a href="#普通索引-2" class="headerlink" title="普通索引"></a>普通索引</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tableName(  <br> <br>ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <br> <br>username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br> <br>INDEX [indexName] (username(length))  <br>); <br></code></pre></div></td></tr></table></figure><h4 id="唯一索引-2"><a href="#唯一索引-2" class="headerlink" title="唯一索引"></a>唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> mytable(  <br> <br>ID <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   <br> <br>username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,  <br> <br><span class="hljs-keyword">UNIQUE</span> [indexName] (username(length))  <br> <br>); <br></code></pre></div></td></tr></table></figure><h3 id="4-删除索引"><a href="#4-删除索引" class="headerlink" title="4. 删除索引"></a>4. 删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX [indexName] <span class="hljs-keyword">on</span> tableName;<br></code></pre></div></td></tr></table></figure><p>或者使用 alert 语句</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tableName <span class="hljs-keyword">DROP</span> INDEX (indexName)；<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
